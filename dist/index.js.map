{"version":3,"file":"index.js","sources":["../webpack://javascript-action/./index.js","../webpack://javascript-action/./node_modules/@actions/core/lib/command.js","../webpack://javascript-action/./node_modules/@actions/core/lib/core.js","../webpack://javascript-action/./node_modules/@actions/core/lib/file-command.js","../webpack://javascript-action/./node_modules/@actions/core/lib/utils.js","../webpack://javascript-action/./node_modules/@actions/exec/lib/exec.js","../webpack://javascript-action/./node_modules/@actions/exec/lib/toolrunner.js","../webpack://javascript-action/./node_modules/@actions/io/lib/io-util.js","../webpack://javascript-action/./node_modules/@actions/io/lib/io.js","../webpack://javascript-action/./node_modules/balanced-match/index.js","../webpack://javascript-action/./node_modules/brace-expansion/index.js","../webpack://javascript-action/./node_modules/concat-map/index.js","../webpack://javascript-action/./node_modules/fs.realpath/index.js","../webpack://javascript-action/./node_modules/fs.realpath/old.js","../webpack://javascript-action/./node_modules/glob/common.js","../webpack://javascript-action/./node_modules/glob/glob.js","../webpack://javascript-action/./node_modules/glob/sync.js","../webpack://javascript-action/./node_modules/inflight/inflight.js","../webpack://javascript-action/./node_modules/inherits/inherits.js","../webpack://javascript-action/./node_modules/inherits/inherits_browser.js","../webpack://javascript-action/./node_modules/matched/index.js","../webpack://javascript-action/./node_modules/matched/lib/async.js","../webpack://javascript-action/./node_modules/matched/lib/promise.js","../webpack://javascript-action/./node_modules/matched/lib/sync.js","../webpack://javascript-action/./node_modules/matched/lib/utils.js","../webpack://javascript-action/./node_modules/minimatch/minimatch.js","../webpack://javascript-action/./node_modules/once/once.js","../webpack://javascript-action/./node_modules/path-is-absolute/index.js","../webpack://javascript-action/./node_modules/path-sort/index.js","../webpack://javascript-action/./node_modules/php-parser/src/ast.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/array.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/arrowfunc.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/assign.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/assignref.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/bin.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/block.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/boolean.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/break.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/byref.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/call.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/case.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/cast.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/catch.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/class.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/classconstant.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/clone.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/closure.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/comment.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/commentblock.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/commentline.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/constant.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/constantstatement.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/continue.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/declaration.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/declare.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/declaredirective.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/do.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/echo.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/empty.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/encapsed.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/encapsedpart.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/entry.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/error.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/eval.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/exit.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/expression.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/expressionstatement.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/for.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/foreach.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/function.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/global.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/goto.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/halt.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/identifier.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/if.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/include.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/inline.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/interface.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/isset.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/label.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/list.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/literal.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/location.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/lookup.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/magic.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/method.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/name.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/namespace.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/new.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/node.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/noop.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/nowdoc.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/nullkeyword.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/number.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/offsetlookup.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/operation.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/parameter.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/parentreference.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/position.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/post.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/pre.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/print.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/program.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/property.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/propertylookup.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/propertystatement.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/reference.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/retif.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/return.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/selfreference.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/silent.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/statement.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/static.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/staticlookup.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/staticreference.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/staticvariable.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/string.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/switch.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/throw.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/trait.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/traitalias.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/traitprecedence.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/traituse.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/try.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/typereference.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/unary.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/unset.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/usegroup.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/useitem.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/variable.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/variadic.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/while.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/yield.js","../webpack://javascript-action/./node_modules/php-parser/src/ast/yieldfrom.js","../webpack://javascript-action/./node_modules/php-parser/src/index.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/comments.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/initial.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/numbers.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/property.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/scripting.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/strings.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/tokens.js","../webpack://javascript-action/./node_modules/php-parser/src/lexer/utils.js","../webpack://javascript-action/./node_modules/php-parser/src/parser.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/array.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/class.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/comment.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/expr.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/function.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/if.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/loops.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/main.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/namespace.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/scalar.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/statement.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/switch.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/try.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/utils.js","../webpack://javascript-action/./node_modules/php-parser/src/parser/variable.js","../webpack://javascript-action/./node_modules/php-parser/src/tokens.js","../webpack://javascript-action/./node_modules/picomatch/index.js","../webpack://javascript-action/./node_modules/picomatch/lib/constants.js","../webpack://javascript-action/./node_modules/picomatch/lib/parse.js","../webpack://javascript-action/./node_modules/picomatch/lib/picomatch.js","../webpack://javascript-action/./node_modules/picomatch/lib/scan.js","../webpack://javascript-action/./node_modules/picomatch/lib/utils.js","../webpack://javascript-action/./node_modules/wp-pot/index.js","../webpack://javascript-action/./node_modules/wp-pot/pot-maker.js","../webpack://javascript-action/./node_modules/wp-pot/translation-parser.js","../webpack://javascript-action/./node_modules/wrappy/wrappy.js","../webpack://javascript-action/external \"assert\"","../webpack://javascript-action/external \"child_process\"","../webpack://javascript-action/external \"events\"","../webpack://javascript-action/external \"fs\"","../webpack://javascript-action/external \"os\"","../webpack://javascript-action/external \"path\"","../webpack://javascript-action/external \"util\"","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/webpack/startup"],"sourcesContent":["const core = require('@actions/core');\nconst exec = require('@actions/exec');\nconst wpPot = require('wp-pot');\n\n\n// most @actions toolkit packages have async methods\nasync function run() {\n  try {\n    const source = core.getInput('source');\n    const destination = core.getInput('destination');\n    const text_domain = core.getInput('text-domain');\n\n    core.info(`Starting generation of POT file ...`);\n\n    const pot = wpPot({\n      src: source,\n      destFile: destination,\n      domain: text_domain,\n    });\n\n    core.info(`${pot}`);\n\n    // Commit the generated POT file.\n    await exec.exec(`git add ${destination}`);\n    await exec.exec(`git commit -m \"Automatically generated POT file\"`);\n    await exec.exec(`git push`);\n\n    core.info(`The POT file was successfully generated.`);\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nrun();\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.  The value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tr = __importStar(require(\"./toolrunner\"));\n/**\n * Exec a command.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.\n * @param     args               optional arguments for tool. Escaping is handled by the lib.\n * @param     options            optional exec options.  See ExecOptions\n * @returns   Promise<number>    exit code\n */\nfunction exec(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const commandArgs = tr.argStringToArray(commandLine);\n        if (commandArgs.length === 0) {\n            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);\n        }\n        // Path to tool to execute should be first arg\n        const toolPath = commandArgs[0];\n        args = commandArgs.slice(1).concat(args || []);\n        const runner = new tr.ToolRunner(toolPath, args, options);\n        return runner.exec();\n    });\n}\nexports.exec = exec;\n//# sourceMappingURL=exec.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst events = __importStar(require(\"events\"));\nconst child = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst ioUtil = __importStar(require(\"@actions/io/lib/io-util\"));\n/* eslint-disable @typescript-eslint/unbound-method */\nconst IS_WINDOWS = process.platform === 'win32';\n/*\n * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.\n */\nclass ToolRunner extends events.EventEmitter {\n    constructor(toolPath, args, options) {\n        super();\n        if (!toolPath) {\n            throw new Error(\"Parameter 'toolPath' cannot be null or empty.\");\n        }\n        this.toolPath = toolPath;\n        this.args = args || [];\n        this.options = options || {};\n    }\n    _debug(message) {\n        if (this.options.listeners && this.options.listeners.debug) {\n            this.options.listeners.debug(message);\n        }\n    }\n    _getCommandString(options, noPrefix) {\n        const toolPath = this._getSpawnFileName();\n        const args = this._getSpawnArgs(options);\n        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool\n        if (IS_WINDOWS) {\n            // Windows + cmd file\n            if (this._isCmdFile()) {\n                cmd += toolPath;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows + verbatim\n            else if (options.windowsVerbatimArguments) {\n                cmd += `\"${toolPath}\"`;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows (regular)\n            else {\n                cmd += this._windowsQuoteCmdArg(toolPath);\n                for (const a of args) {\n                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;\n                }\n            }\n        }\n        else {\n            // OSX/Linux - this can likely be improved with some form of quoting.\n            // creating processes on Unix is fundamentally different than Windows.\n            // on Unix, execvp() takes an arg array.\n            cmd += toolPath;\n            for (const a of args) {\n                cmd += ` ${a}`;\n            }\n        }\n        return cmd;\n    }\n    _processLineBuffer(data, strBuffer, onLine) {\n        try {\n            let s = strBuffer + data.toString();\n            let n = s.indexOf(os.EOL);\n            while (n > -1) {\n                const line = s.substring(0, n);\n                onLine(line);\n                // the rest of the string ...\n                s = s.substring(n + os.EOL.length);\n                n = s.indexOf(os.EOL);\n            }\n            strBuffer = s;\n        }\n        catch (err) {\n            // streaming lines to console is best effort.  Don't fail a build.\n            this._debug(`error processing line. Failed with error ${err}`);\n        }\n    }\n    _getSpawnFileName() {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                return process.env['COMSPEC'] || 'cmd.exe';\n            }\n        }\n        return this.toolPath;\n    }\n    _getSpawnArgs(options) {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                let argline = `/D /S /C \"${this._windowsQuoteCmdArg(this.toolPath)}`;\n                for (const a of this.args) {\n                    argline += ' ';\n                    argline += options.windowsVerbatimArguments\n                        ? a\n                        : this._windowsQuoteCmdArg(a);\n                }\n                argline += '\"';\n                return [argline];\n            }\n        }\n        return this.args;\n    }\n    _endsWith(str, end) {\n        return str.endsWith(end);\n    }\n    _isCmdFile() {\n        const upperToolPath = this.toolPath.toUpperCase();\n        return (this._endsWith(upperToolPath, '.CMD') ||\n            this._endsWith(upperToolPath, '.BAT'));\n    }\n    _windowsQuoteCmdArg(arg) {\n        // for .exe, apply the normal quoting rules that libuv applies\n        if (!this._isCmdFile()) {\n            return this._uvQuoteCmdArg(arg);\n        }\n        // otherwise apply quoting rules specific to the cmd.exe command line parser.\n        // the libuv rules are generic and are not designed specifically for cmd.exe\n        // command line parser.\n        //\n        // for a detailed description of the cmd.exe command line parser, refer to\n        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912\n        // need quotes for empty arg\n        if (!arg) {\n            return '\"\"';\n        }\n        // determine whether the arg needs to be quoted\n        const cmdSpecialChars = [\n            ' ',\n            '\\t',\n            '&',\n            '(',\n            ')',\n            '[',\n            ']',\n            '{',\n            '}',\n            '^',\n            '=',\n            ';',\n            '!',\n            \"'\",\n            '+',\n            ',',\n            '`',\n            '~',\n            '|',\n            '<',\n            '>',\n            '\"'\n        ];\n        let needsQuotes = false;\n        for (const char of arg) {\n            if (cmdSpecialChars.some(x => x === char)) {\n                needsQuotes = true;\n                break;\n            }\n        }\n        // short-circuit if quotes not needed\n        if (!needsQuotes) {\n            return arg;\n        }\n        // the following quoting rules are very similar to the rules that by libuv applies.\n        //\n        // 1) wrap the string in quotes\n        //\n        // 2) double-up quotes - i.e. \" => \"\"\n        //\n        //    this is different from the libuv quoting rules. libuv replaces \" with \\\", which unfortunately\n        //    doesn't work well with a cmd.exe command line.\n        //\n        //    note, replacing \" with \"\" also works well if the arg is passed to a downstream .NET console app.\n        //    for example, the command line:\n        //          foo.exe \"myarg:\"\"my val\"\"\"\n        //    is parsed by a .NET console app into an arg array:\n        //          [ \"myarg:\\\"my val\\\"\" ]\n        //    which is the same end result when applying libuv quoting rules. although the actual\n        //    command line from libuv quoting rules would look like:\n        //          foo.exe \"myarg:\\\"my val\\\"\"\n        //\n        // 3) double-up slashes that precede a quote,\n        //    e.g.  hello \\world    => \"hello \\world\"\n        //          hello\\\"world    => \"hello\\\\\"\"world\"\n        //          hello\\\\\"world   => \"hello\\\\\\\\\"\"world\"\n        //          hello world\\    => \"hello world\\\\\"\n        //\n        //    technically this is not required for a cmd.exe command line, or the batch argument parser.\n        //    the reasons for including this as a .cmd quoting rule are:\n        //\n        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an\n        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.\n        //\n        //    b) it's what we've been doing previously (by deferring to node default behavior) and we\n        //       haven't heard any complaints about that aspect.\n        //\n        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be\n        // escaped when used on the command line directly - even though within a .cmd file % can be escaped\n        // by using %%.\n        //\n        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts\n        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.\n        //\n        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would\n        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the\n        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args\n        // to an external program.\n        //\n        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.\n        // % can be escaped within a .cmd file.\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\'; // double the slash\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\"'; // double the quote\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _uvQuoteCmdArg(arg) {\n        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as\n        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments\n        // is used.\n        //\n        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,\n        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),\n        // pasting copyright notice from Node within this function:\n        //\n        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n        //\n        //      Permission is hereby granted, free of charge, to any person obtaining a copy\n        //      of this software and associated documentation files (the \"Software\"), to\n        //      deal in the Software without restriction, including without limitation the\n        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n        //      sell copies of the Software, and to permit persons to whom the Software is\n        //      furnished to do so, subject to the following conditions:\n        //\n        //      The above copyright notice and this permission notice shall be included in\n        //      all copies or substantial portions of the Software.\n        //\n        //      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n        //      IN THE SOFTWARE.\n        if (!arg) {\n            // Need double quotation for empty argument\n            return '\"\"';\n        }\n        if (!arg.includes(' ') && !arg.includes('\\t') && !arg.includes('\"')) {\n            // No quotation needed\n            return arg;\n        }\n        if (!arg.includes('\"') && !arg.includes('\\\\')) {\n            // No embedded double quotes or backslashes, so I can just wrap\n            // quote marks around the whole thing.\n            return `\"${arg}\"`;\n        }\n        // Expected input/output:\n        //   input : hello\"world\n        //   output: \"hello\\\"world\"\n        //   input : hello\"\"world\n        //   output: \"hello\\\"\\\"world\"\n        //   input : hello\\world\n        //   output: hello\\world\n        //   input : hello\\\\world\n        //   output: hello\\\\world\n        //   input : hello\\\"world\n        //   output: \"hello\\\\\\\"world\"\n        //   input : hello\\\\\"world\n        //   output: \"hello\\\\\\\\\\\"world\"\n        //   input : hello world\\\n        //   output: \"hello world\\\\\" - note the comment in libuv actually reads \"hello world\\\"\n        //                             but it appears the comment is wrong, it should be \"hello world\\\\\"\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\';\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\\\\';\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _cloneExecOptions(options) {\n        options = options || {};\n        const result = {\n            cwd: options.cwd || process.cwd(),\n            env: options.env || process.env,\n            silent: options.silent || false,\n            windowsVerbatimArguments: options.windowsVerbatimArguments || false,\n            failOnStdErr: options.failOnStdErr || false,\n            ignoreReturnCode: options.ignoreReturnCode || false,\n            delay: options.delay || 10000\n        };\n        result.outStream = options.outStream || process.stdout;\n        result.errStream = options.errStream || process.stderr;\n        return result;\n    }\n    _getSpawnOptions(options, toolPath) {\n        options = options || {};\n        const result = {};\n        result.cwd = options.cwd;\n        result.env = options.env;\n        result['windowsVerbatimArguments'] =\n            options.windowsVerbatimArguments || this._isCmdFile();\n        if (options.windowsVerbatimArguments) {\n            result.argv0 = `\"${toolPath}\"`;\n        }\n        return result;\n    }\n    /**\n     * Exec a tool.\n     * Output will be streamed to the live console.\n     * Returns promise with return code\n     *\n     * @param     tool     path to tool to exec\n     * @param     options  optional exec options.  See ExecOptions\n     * @returns   number\n     */\n    exec() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // root the tool path if it is unrooted and contains relative pathing\n            if (!ioUtil.isRooted(this.toolPath) &&\n                (this.toolPath.includes('/') ||\n                    (IS_WINDOWS && this.toolPath.includes('\\\\')))) {\n                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted\n                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);\n            }\n            // if the tool is only a file name, then resolve it from the PATH\n            // otherwise verify it exists (add extension on Windows if necessary)\n            this.toolPath = yield io.which(this.toolPath, true);\n            return new Promise((resolve, reject) => {\n                this._debug(`exec tool: ${this.toolPath}`);\n                this._debug('arguments:');\n                for (const arg of this.args) {\n                    this._debug(`   ${arg}`);\n                }\n                const optionsNonNull = this._cloneExecOptions(this.options);\n                if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n                }\n                const state = new ExecState(optionsNonNull, this.toolPath);\n                state.on('debug', (message) => {\n                    this._debug(message);\n                });\n                const fileName = this._getSpawnFileName();\n                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));\n                const stdbuffer = '';\n                if (cp.stdout) {\n                    cp.stdout.on('data', (data) => {\n                        if (this.options.listeners && this.options.listeners.stdout) {\n                            this.options.listeners.stdout(data);\n                        }\n                        if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                            optionsNonNull.outStream.write(data);\n                        }\n                        this._processLineBuffer(data, stdbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.stdline) {\n                                this.options.listeners.stdline(line);\n                            }\n                        });\n                    });\n                }\n                const errbuffer = '';\n                if (cp.stderr) {\n                    cp.stderr.on('data', (data) => {\n                        state.processStderr = true;\n                        if (this.options.listeners && this.options.listeners.stderr) {\n                            this.options.listeners.stderr(data);\n                        }\n                        if (!optionsNonNull.silent &&\n                            optionsNonNull.errStream &&\n                            optionsNonNull.outStream) {\n                            const s = optionsNonNull.failOnStdErr\n                                ? optionsNonNull.errStream\n                                : optionsNonNull.outStream;\n                            s.write(data);\n                        }\n                        this._processLineBuffer(data, errbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.errline) {\n                                this.options.listeners.errline(line);\n                            }\n                        });\n                    });\n                }\n                cp.on('error', (err) => {\n                    state.processError = err.message;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    state.CheckComplete();\n                });\n                cp.on('exit', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                cp.on('close', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                state.on('done', (error, exitCode) => {\n                    if (stdbuffer.length > 0) {\n                        this.emit('stdline', stdbuffer);\n                    }\n                    if (errbuffer.length > 0) {\n                        this.emit('errline', errbuffer);\n                    }\n                    cp.removeAllListeners();\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(exitCode);\n                    }\n                });\n                if (this.options.input) {\n                    if (!cp.stdin) {\n                        throw new Error('child process missing stdin');\n                    }\n                    cp.stdin.end(this.options.input);\n                }\n            });\n        });\n    }\n}\nexports.ToolRunner = ToolRunner;\n/**\n * Convert an arg string to an array of args. Handles escaping\n *\n * @param    argString   string of arguments\n * @returns  string[]    array of arguments\n */\nfunction argStringToArray(argString) {\n    const args = [];\n    let inQuotes = false;\n    let escaped = false;\n    let arg = '';\n    function append(c) {\n        // we only escape double quotes.\n        if (escaped && c !== '\"') {\n            arg += '\\\\';\n        }\n        arg += c;\n        escaped = false;\n    }\n    for (let i = 0; i < argString.length; i++) {\n        const c = argString.charAt(i);\n        if (c === '\"') {\n            if (!escaped) {\n                inQuotes = !inQuotes;\n            }\n            else {\n                append(c);\n            }\n            continue;\n        }\n        if (c === '\\\\' && escaped) {\n            append(c);\n            continue;\n        }\n        if (c === '\\\\' && inQuotes) {\n            escaped = true;\n            continue;\n        }\n        if (c === ' ' && !inQuotes) {\n            if (arg.length > 0) {\n                args.push(arg);\n                arg = '';\n            }\n            continue;\n        }\n        append(c);\n    }\n    if (arg.length > 0) {\n        args.push(arg.trim());\n    }\n    return args;\n}\nexports.argStringToArray = argStringToArray;\nclass ExecState extends events.EventEmitter {\n    constructor(options, toolPath) {\n        super();\n        this.processClosed = false; // tracks whether the process has exited and stdio is closed\n        this.processError = '';\n        this.processExitCode = 0;\n        this.processExited = false; // tracks whether the process has exited\n        this.processStderr = false; // tracks whether stderr was written to\n        this.delay = 10000; // 10 seconds\n        this.done = false;\n        this.timeout = null;\n        if (!toolPath) {\n            throw new Error('toolPath must not be empty');\n        }\n        this.options = options;\n        this.toolPath = toolPath;\n        if (options.delay) {\n            this.delay = options.delay;\n        }\n    }\n    CheckComplete() {\n        if (this.done) {\n            return;\n        }\n        if (this.processClosed) {\n            this._setResult();\n        }\n        else if (this.processExited) {\n            this.timeout = setTimeout(ExecState.HandleTimeout, this.delay, this);\n        }\n    }\n    _debug(message) {\n        this.emit('debug', message);\n    }\n    _setResult() {\n        // determine whether there is an error\n        let error;\n        if (this.processExited) {\n            if (this.processError) {\n                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);\n            }\n            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {\n                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);\n            }\n            else if (this.processStderr && this.options.failOnStdErr) {\n                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);\n            }\n        }\n        // clear the timeout\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.done = true;\n        this.emit('done', error, this.processExitCode);\n    }\n    static HandleTimeout(state) {\n        if (state.done) {\n            return;\n        }\n        if (!state.processClosed && state.processExited) {\n            const message = `The STDIO streams did not close within ${state.delay /\n                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;\n            state._debug(message);\n        }\n        state._setResult();\n    }\n}\n//# sourceMappingURL=toolrunner.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = require(\"assert\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\nexports.IS_WINDOWS = process.platform === 'win32';\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Recursively create a directory at `fsPath`.\n *\n * This implementation is optimistic, meaning it attempts to create the full\n * path first, and backs up the path stack from there.\n *\n * @param fsPath The path to create\n * @param maxDepth The maximum recursion depth\n * @param depth The current recursion depth\n */\nfunction mkdirP(fsPath, maxDepth = 1000, depth = 1) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        fsPath = path.resolve(fsPath);\n        if (depth >= maxDepth)\n            return exports.mkdir(fsPath);\n        try {\n            yield exports.mkdir(fsPath);\n            return;\n        }\n        catch (err) {\n            switch (err.code) {\n                case 'ENOENT': {\n                    yield mkdirP(path.dirname(fsPath), maxDepth, depth + 1);\n                    yield exports.mkdir(fsPath);\n                    return;\n                }\n                default: {\n                    let stats;\n                    try {\n                        stats = yield exports.stat(fsPath);\n                    }\n                    catch (err2) {\n                        throw err;\n                    }\n                    if (!stats.isDirectory())\n                        throw err;\n                }\n            }\n        }\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst childProcess = require(\"child_process\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst ioUtil = require(\"./io-util\");\nconst exec = util_1.promisify(childProcess.exec);\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory()\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another\n            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.\n            try {\n                if (yield ioUtil.isDirectory(inputPath, true)) {\n                    yield exec(`rd /s /q \"${inputPath}\"`);\n                }\n                else {\n                    yield exec(`del /f /a \"${inputPath}\"`);\n                }\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that\n            try {\n                yield ioUtil.unlink(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n            }\n        }\n        else {\n            let isDir = false;\n            try {\n                isDir = yield ioUtil.isDirectory(inputPath);\n            }\n            catch (err) {\n                // if you try to delete a file that doesn't exist, desired result is achieved\n                // other errors are valid\n                if (err.code !== 'ENOENT')\n                    throw err;\n                return;\n            }\n            if (isDir) {\n                yield exec(`rm -rf \"${inputPath}\"`);\n            }\n            else {\n                yield ioUtil.unlink(inputPath);\n            }\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ioUtil.mkdirP(fsPath);\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n        }\n        try {\n            // build the list of extensions to try\n            const extensions = [];\n            if (ioUtil.IS_WINDOWS && process.env.PATHEXT) {\n                for (const extension of process.env.PATHEXT.split(path.delimiter)) {\n                    if (extension) {\n                        extensions.push(extension);\n                    }\n                }\n            }\n            // if it's rooted, return it if exists. otherwise return empty.\n            if (ioUtil.isRooted(tool)) {\n                const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n                if (filePath) {\n                    return filePath;\n                }\n                return '';\n            }\n            // if any path separators, return empty\n            if (tool.includes('/') || (ioUtil.IS_WINDOWS && tool.includes('\\\\'))) {\n                return '';\n            }\n            // build the list of directories\n            //\n            // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n            // it feels like we should not do this. Checking the current directory seems like more of a use\n            // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n            // across platforms.\n            const directories = [];\n            if (process.env.PATH) {\n                for (const p of process.env.PATH.split(path.delimiter)) {\n                    if (p) {\n                        directories.push(p);\n                    }\n                }\n            }\n            // return the first match\n            for (const directory of directories) {\n                const filePath = yield ioUtil.tryGetExecutablePath(directory + path.sep + tool, extensions);\n                if (filePath) {\n                    return filePath;\n                }\n            }\n            return '';\n        }\n        catch (err) {\n            throw new Error(`which failed with message ${err.message}`);\n        }\n    });\n}\nexports.which = which;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    return { force, recursive };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = require('fs')\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = require('./old.js')\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n","exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nmodule.exports = require('./lib/async');\nmodule.exports.sync = require('./lib/sync');\nmodule.exports.promise = require('./lib/promise');\n","'use strict';\n\nconst glob = require('./promise');\n\nmodule.exports = (patterns, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = void 0;\n  }\n\n  const promise = glob(patterns, options);\n\n  if (typeof callback === 'function') {\n    promise.then(files => callback(null, files)).catch(callback);\n    return;\n  }\n\n  return promise;\n};\n","'use strict';\n\nconst path = require('path');\nconst utils = require('./utils');\nconst { Glob } = require('glob');\n\nconst glob = (pattern, options) => {\n  const onMatch = utils.onMatch(pattern, options);\n\n  return new Promise((resolve, reject) => {\n    const globber = new Glob(pattern, options, (err, files) => {\n      globber.off('match', onMatch);\n\n      if (err) {\n        reject(err);\n      } else {\n        resolve(files);\n      }\n    });\n\n    globber.on('match', onMatch);\n  });\n};\n\nmodule.exports = async (patterns, options) => {\n  const { expand, getPaths, sift, setIgnores } = utils;\n  patterns = [].concat(patterns || []);\n\n  const opts = { cwd: '.', nosort: true, ...options };\n  opts.cwd = path.resolve(expand(opts.cwd));\n\n  const sifted = sift(patterns, opts);\n  if (sifted === null) {\n    return Promise.reject(new Error('invalid glob pattern: ' + patterns));\n  }\n\n  if (sifted.globs === 0) {\n    return Promise.resolve(getPaths(patterns, opts));\n  }\n\n  const { excludes, includes } = sifted;\n  const config = include => setIgnores(opts, excludes, include.index);\n  const pending = [];\n  const files = [];\n\n  const onFiles = options => {\n    return dirents => {\n      files.push(...dirents);\n\n      if (options.onFiles) {\n        return options.onFiles(dirents, options);\n      }\n    };\n  };\n\n  for (const include of includes) {\n    const opt = config(include);\n    pending.push(glob(include.pattern, opt).then(onFiles(opt)));\n  }\n\n  return Promise.all(pending).then(() => files);\n};\n","'use strict';\n\nconst path = require('path');\nconst glob = require('glob');\nconst utils = require('./utils');\n\nmodule.exports = (patterns, options) => {\n  const { expand, getPaths, sift, setIgnores } = utils;\n  patterns = [].concat(patterns || []);\n\n  // shallow clone options\n  const opts = { cwd: '.', nosort: true, ...options };\n  opts.cwd = path.resolve(expand(opts.cwd));\n\n  const sifted = sift(patterns, opts);\n  if (sifted === null) {\n    throw new Error('invalid glob pattern: ' + patterns);\n  }\n\n  if (sifted.globs === 0) {\n    return getPaths(patterns, opts);\n  }\n\n  const { excludes, includes } = sifted;\n  const config = include => setIgnores(opts, excludes, include.index);\n  const files = [];\n\n  for (const include of includes) {\n    const dirOpts = config(include);\n\n    // simulate onMatch, for parity with async\n    const dirents = glob.sync(include.pattern, dirOpts);\n    const onMatch = utils.onMatch(include.pattern, options);\n    dirents.forEach(dirent => {\n      files.push(dirent);\n      onMatch(dirent);\n    });\n\n    if (dirOpts.onFiles) {\n      dirOpts.onFiles(dirents, dirOpts);\n    }\n  }\n  return files;\n};\n","'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst picomatch = require('picomatch');\nconst union = (...args) => [...new Set([].concat.apply([], args).filter(Boolean))];\n\n/**\n * Expand tilde\n */\n\nexports.expand = str => str.replace(/^~/, os.homedir());\n\n/**\n * Sift glob patterns into inclusive and exclusive patterns.\n *\n * @param {String|Array} `patterns`\n * @param {Object} opts\n * @return {Object}\n */\n\nexports.sift = (patterns, options = {}) => {\n  const results = { includes: [], excludes: [], globs: 0 };\n  let index = 0;\n\n  for (const pattern of [].concat(patterns || [])) {\n    if (typeof pattern !== 'string') return null;\n    const res = picomatch.scan(pattern);\n    res.pattern = path.posix.join(res.base, res.glob);\n    res.index = index++;\n\n    if (res.isGlob) results.globs++;\n    if (options.relative) {\n      res.pattern = exports.toRelative(res.pattern, options);\n      delete options.cwd;\n    }\n\n    if (res.negated) {\n      results.excludes.push(res);\n    } else {\n      results.includes.push(res);\n    }\n  }\n  return results;\n};\n\n/**\n * Set the index of ignore patterns based on their position\n * in an array of globs.\n *\n * @param {Object} `options`\n * @param {Array} `excludes`\n * @param {Number} `inclusiveIndex`\n */\n\nexports.setIgnores = (options, excludes, inclusiveIndex) => {\n  const opts = Object.assign({}, options);\n  const negations = [];\n\n  for (const exclusive of excludes) {\n    if (exclusive.index > inclusiveIndex) {\n      negations.push(exclusive.pattern);\n    }\n  }\n\n  opts.ignore = union([], opts.ignore, negations);\n  return opts;\n};\n\n/**\n * Make a glob pattern relative.\n *\n * @param {String} `pattern`\n * @param {Object} `opts`\n * @return {String}\n */\n\nexports.toRelative = (pattern, opts) => {\n  return path.relative(process.cwd(), path.resolve(exports.expand(opts.cwd), pattern));\n};\n\n/**\n * Create an event listener for .on('match', ...).\n *\n * @param {String} pattern\n * @param {Object} options\n * @return {Function}\n */\n\nexports.onMatch = (pattern, options) => {\n  return filepath => {\n    if (options && typeof options.onMatch === 'function') {\n      options.onMatch({ pattern, options, path: filepath });\n    }\n  };\n};\n\n/**\n * Get paths from non-glob patterns\n *\n * @param {Array} `paths`\n * @param {Object} `opts`\n * @return {Array}\n */\n\nexports.getPaths = (paths, options = {}) => {\n  const resolve = fp => path.resolve(exports.expand(options.cwd), fp);\n  const result = [];\n\n  for (const filepath of paths) {\n    const onMatch = exports.onMatch(filepath, options);\n    const absolute = resolve(filepath);\n    let resolved = filepath;\n\n    if (options.absolute) {\n      resolved = absolute;\n    }\n\n    if (options.realpath) {\n      try {\n        resolved = fs.realpathSync(absolute);\n      } catch (err) {\n        continue;\n      }\n    }\n\n    if (!fs.existsSync(absolute)) {\n      continue;\n    }\n\n    if (options.onMatch) {\n      onMatch(resolved);\n    }\n\n    result.push(resolved);\n  }\n\n  if (options.onFiles) {\n    options.onFiles(result, options);\n  }\n\n  return result;\n};\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","module.exports = pathsort\nmodule.exports.standalone = standalone\n\nfunction pathsort(paths, sep) {\n  sep = sep || '/'\n\n  return paths.map(function(el) {\n    return el.split(sep)\n  }).sort(sorter).map(function(el) {\n    return el.join(sep)\n  })\n}\n\nfunction sorter(a, b) {\n  var l = Math.max(a.length, b.length)\n  for (var i = 0; i < l; i += 1) {\n    if (!(i in a)) return -1\n    if (!(i in b)) return +1\n    if (a[i].toUpperCase() > b[i].toUpperCase()) return +1\n    if (a[i].toUpperCase() < b[i].toUpperCase()) return -1\n    if (a.length < b.length) return -1\n    if (a.length > b.length) return +1\n  }\n}\n\nfunction standalone(sep) {\n  sep = sep || '/'\n  return function pathsort(a, b) {\n    return sorter(a.split(sep), b.split(sep))\n  }\n}\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Location = require(\"./ast/location\");\nconst Position = require(\"./ast/position\");\n\n/**\n * ## Class hierarchy\n *\n * - [Location](#location)\n * - [Position](#position)\n * - [Node](#node)\n *   - [Noop](#noop)\n *   - [NullKeyword](#nullkeyword)\n *   - [StaticVariable](#staticvariable)\n *   - [EncapsedPart](#encapsedpart)\n *   - [Constant](#constant)\n *   - [Identifier](#identifier)\n *   - [Reference](#reference)\n *     - [TypeReference](#typereference)\n *     - [ParentReference](#parentreference)\n *     - [StaticReference](#staticreference)\n *     - [SelfReference](#selfreference)\n *     - [Name](#name)\n *   - [TraitUse](#traituse)\n *   - [TraitAlias](#traitalias)\n *   - [TraitPrecedence](#traitprecedence)\n *   - [Comment](#comment)\n *     - [CommentLine](#commentline)\n *     - [CommentBlock](#commentblock)\n *   - [Error](#error)\n *   - [Expression](#expression)\n *     - [Entry](#entry)\n *     - [ArrowFunc](#arrowfunc)\n *     - [Closure](#closure)\n *     - [ByRef](#byref)\n *     - [Silent](#silent)\n *     - [RetIf](#retif)\n *     - [New](#new)\n *     - [Include](#include)\n *     - [Call](#call)\n *     - [Eval](#eval)\n *     - [Exit](#exit)\n *     - [Clone](#clone)\n *     - [Assign](#assign)\n *     - [AssignRef](#assignref)\n *     - [Array](#array)\n *     - [List](#list)\n *     - [Variable](#variable)\n *     - [Variadic](#variadic)\n *     - [Yield](#yield)\n *     - [YieldFrom](#yieldfrom)\n *     - [Print](#print)\n *     - [Isset](#isset)\n *     - [Empty](#empty)\n *     - [Lookup](#lookup)\n *       - [PropertyLookup](#propertylookup)\n *       - [StaticLookup](#staticlookup)\n *       - [OffsetLookup](#offsetlookup)\n *     - [Operation](#operation)\n *       - [Pre](#pre)\n *       - [Post](#post)\n *       - [Bin](#bin)\n *       - [Unary](#unary)\n *       - [Cast](#cast)\n *     - [Literal](#literal)\n *       - [Boolean](#boolean)\n *       - [String](#string)\n *       - [Number](#number)\n *       - [Inline](#inline)\n *       - [Magic](#magic)\n *       - [Nowdoc](#nowdoc)\n *       - [Encapsed](#encapsed)\n *   - [Statement](#statement)\n *     - [ConstantStatement](#constantstatement)\n *       - [ClassConstant](#classconstant)\n *     - [Return](#return)\n *     - [Label](#label)\n *     - [Continue](#continue)\n *     - [Case](#case)\n *     - [Break](#break)\n *     - [Echo](#echo)\n *     - [Unset](#unset)\n *     - [Halt](#halt)\n *     - [Declare](#declare)\n *     - [Global](#global)\n *     - [Static](#static)\n *     - [If](#if)\n *     - [Do](#do)\n *     - [While](#while)\n *     - [For](#for)\n *     - [Foreach](#foreach)\n *     - [Switch](#switch)\n *     - [Goto](#goto)\n *     - [Try](#try)\n *     - [Catch](#catch)\n *     - [Throw](#throw)\n *     - [UseGroup](#usegroup)\n *     - [UseItem](#useitem)\n *     - [Block](#block)\n *       - [Program](#program)\n *       - [Namespace](#namespace)\n *     - [PropertyStatement](#propertystatement)\n *     - [Property](#property)\n *     - [Declaration](#declaration)\n *       - [Class](#class)\n *       - [Interface](#interface)\n *       - [Trait](#trait)\n *       - [Function](#function)\n *         - [Method](#method)\n *       - [Parameter](#parameter)\n * ---\n */\n\n/**\n * The AST builder class\n * @constructor AST\n * @tutorial AST\n * @property {Boolean} withPositions - Should locate any node (by default false)\n * @property {Boolean} withSource - Should extract the node original code (by default false)\n */\nconst AST = function (withPositions, withSource) {\n  this.withPositions = withPositions;\n  this.withSource = withSource;\n};\n\n/**\n * Create a position node from specified parser\n * including it's lexer current state\n * @param {Parser}\n * @return {Position}\n * @private\n */\nAST.prototype.position = function (parser) {\n  return new Position(\n    parser.lexer.yylloc.first_line,\n    parser.lexer.yylloc.first_column,\n    parser.lexer.yylloc.first_offset\n  );\n};\n\n// operators in ascending order of precedence\nAST.precedence = {};\n[\n  [\"or\"],\n  [\"xor\"],\n  [\"and\"],\n  [\"=\"],\n  [\"?\"],\n  [\"??\"],\n  [\"||\"],\n  [\"&&\"],\n  [\"|\"],\n  [\"^\"],\n  [\"&\"],\n  [\"==\", \"!=\", \"===\", \"!==\", /* '<>', */ \"<=>\"],\n  [\"<\", \"<=\", \">\", \">=\"],\n  [\"<<\", \">>\"],\n  [\"+\", \"-\", \".\"],\n  [\"*\", \"/\", \"%\"],\n  [\"!\"],\n  [\"instanceof\"],\n  [\"cast\", \"silent\"],\n  [\"**\"],\n  // TODO: [ (array)\n  // TODO: clone, new\n].forEach(function (list, index) {\n  list.forEach(function (operator) {\n    AST.precedence[operator] = index + 1;\n  });\n});\n\nAST.prototype.isRightAssociative = function (operator) {\n  return operator === \"**\" || operator === \"??\";\n};\n\n/**\n * Change parent node informations after swapping childs\n */\nAST.prototype.swapLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    target.loc.start = first.loc.start;\n    target.loc.end = last.loc.end;\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(\n        target.loc.start.offset,\n        target.loc.end.offset\n      );\n    }\n  }\n};\n\n/**\n * Includes locations from first & last into the target\n */\nAST.prototype.resolveLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    if (target.loc.start.offset > first.loc.start.offset) {\n      target.loc.start = first.loc.start;\n    }\n    if (target.loc.end.offset < last.loc.end.offset) {\n      target.loc.end = last.loc.end;\n    }\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(\n        target.loc.start.offset,\n        target.loc.end.offset\n      );\n    }\n  }\n};\n\n/**\n * Check and fix precence, by default using right\n */\nAST.prototype.resolvePrecedence = function (result, parser) {\n  let buffer, lLevel, rLevel;\n  // handling precendence\n  if (result.kind === \"call\") {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result, parser);\n  } else if (\n    result.kind === \"propertylookup\" ||\n    result.kind === \"staticlookup\" ||\n    (result.kind === \"offsetlookup\" && result.offset)\n  ) {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result.offset, parser);\n  } else if (result.kind === \"bin\") {\n    if (result.right && !result.right.parenthesizedExpression) {\n      if (result.right.kind === \"bin\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[result.right.type];\n        if (\n          lLevel &&\n          rLevel &&\n          rLevel <= lLevel &&\n          (result.type !== result.right.type ||\n            !this.isRightAssociative(result.type))\n        ) {\n          // https://github.com/glayzzle/php-parser/issues/79\n          // shift precedence\n          buffer = result.right;\n          result.right = result.right.left;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.left = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.left, buffer.right, parser);\n          result = buffer;\n        }\n      } else if (result.right.kind === \"retif\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[\"?\"];\n        if (lLevel && rLevel && rLevel <= lLevel) {\n          buffer = result.right;\n          result.right = result.right.test;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.test = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n          result = buffer;\n        }\n      }\n    }\n  } else if (\n    (result.kind === \"silent\" || result.kind === \"cast\") &&\n    result.expr &&\n    !result.expr.parenthesizedExpression\n  ) {\n    // https://github.com/glayzzle/php-parser/issues/172\n    if (result.expr.kind === \"bin\") {\n      buffer = result.expr;\n      result.expr = result.expr.left;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.left = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.left, buffer.right, parser);\n      result = buffer;\n    } else if (result.expr.kind === \"retif\") {\n      buffer = result.expr;\n      result.expr = result.expr.test;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"unary\") {\n    // https://github.com/glayzzle/php-parser/issues/75\n    if (result.what && !result.what.parenthesizedExpression) {\n      // unary precedence is allways lower\n      if (result.what.kind === \"bin\") {\n        buffer = result.what;\n        result.what = result.what.left;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.left = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.left, buffer.right, parser);\n        result = buffer;\n      } else if (result.what.kind === \"retif\") {\n        buffer = result.what;\n        result.what = result.what.test;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.test = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"retif\") {\n    // https://github.com/glayzzle/php-parser/issues/77\n    if (\n      result.falseExpr &&\n      result.falseExpr.kind === \"retif\" &&\n      !result.falseExpr.parenthesizedExpression\n    ) {\n      buffer = result.falseExpr;\n      result.falseExpr = buffer.test;\n      this.swapLocations(result, result.test, result.falseExpr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"assign\") {\n    // https://github.com/glayzzle/php-parser/issues/81\n    if (\n      result.right &&\n      result.right.kind === \"bin\" &&\n      !result.right.parenthesizedExpression\n    ) {\n      lLevel = AST.precedence[\"=\"];\n      rLevel = AST.precedence[result.right.type];\n      // only shifts with and, xor, or\n      if (lLevel && rLevel && rLevel < lLevel) {\n        buffer = result.right;\n        result.right = result.right.left;\n        buffer.left = result;\n        this.swapLocations(buffer, buffer.left, result.right, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"expressionstatement\") {\n    this.swapLocations(result, result.expression, result, parser);\n  }\n  return result;\n};\n\n/**\n * Prepares an AST node\n * @param {String|null} kind - Defines the node type\n * (if null, the kind must be passed at the function call)\n * @param {Parser} parser - The parser instance (use for extracting locations)\n * @return {Function}\n */\nAST.prototype.prepare = function (kind, docs, parser) {\n  let start = null;\n  if (this.withPositions || this.withSource) {\n    start = this.position(parser);\n  }\n  const self = this;\n  // returns the node\n  const result = function () {\n    let location = null;\n    const args = Array.prototype.slice.call(arguments);\n    args.push(docs);\n    if (self.withPositions || self.withSource) {\n      let src = null;\n      if (self.withSource) {\n        src = parser.lexer._input.substring(start.offset, parser.prev[2]);\n      }\n      // if with source, need location on swapLocations function\n      location = new Location(\n        src,\n        start,\n        new Position(parser.prev[0], parser.prev[1], parser.prev[2])\n      );\n      // last argument is allways the location\n      args.push(location);\n    }\n    // handle lazy kind definitions\n    if (!kind) {\n      kind = args.shift();\n    }\n    // build the object\n    const node = self[kind];\n    if (typeof node !== \"function\") {\n      throw new Error('Undefined node \"' + kind + '\"');\n    }\n    const astNode = Object.create(node.prototype);\n    node.apply(astNode, args);\n    result.instance = astNode;\n    if (result.trailingComments) {\n      // buffer of trailingComments\n      astNode.trailingComments = result.trailingComments;\n    }\n    if (typeof result.postBuild === \"function\") {\n      result.postBuild(astNode);\n    }\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n    return self.resolvePrecedence(astNode, parser);\n  };\n  if (parser.debug) {\n    if (!AST.stack) {\n      AST.stack = {};\n      AST.stackUid = 1;\n    }\n    AST.stack[++AST.stackUid] = {\n      position: start,\n      stack: new Error().stack.split(\"\\n\").slice(3, 5),\n    };\n    result.stackUid = AST.stackUid;\n  }\n\n  /**\n   * Sets a list of trailing comments\n   * @param {*} docs\n   */\n  result.setTrailingComments = function (docs) {\n    if (result.instance) {\n      // already created\n      result.instance.setTrailingComments(docs);\n    } else {\n      result.trailingComments = docs;\n    }\n  };\n\n  /**\n   * Release a node without using it on the AST\n   */\n  result.destroy = function (target) {\n    if (docs) {\n      // release current docs stack\n      if (target) {\n        if (!target.leadingComments) {\n          target.leadingComments = docs;\n        } else {\n          target.leadingComments = docs.concat(target.leadingComments);\n        }\n      } else {\n        parser._docIndex = parser._docs.length - docs.length;\n      }\n    }\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n  };\n  return result;\n};\n\nAST.prototype.checkNodes = function () {\n  const errors = [];\n  for (const k in AST.stack) {\n    if (AST.stack.hasOwnProperty(k)) {\n      errors.push(AST.stack[k]);\n    }\n  }\n  AST.stack = {};\n  return errors;\n};\n\n// Define all AST nodes\n[\n  require(\"./ast/array\"),\n  require(\"./ast/arrowfunc\"),\n  require(\"./ast/assign\"),\n  require(\"./ast/assignref\"),\n  require(\"./ast/bin\"),\n  require(\"./ast/block\"),\n  require(\"./ast/boolean\"),\n  require(\"./ast/break\"),\n  require(\"./ast/byref\"),\n  require(\"./ast/call\"),\n  require(\"./ast/case\"),\n  require(\"./ast/cast\"),\n  require(\"./ast/catch\"),\n  require(\"./ast/class\"),\n  require(\"./ast/classconstant\"),\n  require(\"./ast/clone\"),\n  require(\"./ast/closure\"),\n  require(\"./ast/comment\"),\n  require(\"./ast/commentblock\"),\n  require(\"./ast/commentline\"),\n  require(\"./ast/constant\"),\n  require(\"./ast/constantstatement\"),\n  require(\"./ast/continue\"),\n  require(\"./ast/declaration\"),\n  require(\"./ast/declare\"),\n  require(\"./ast/declaredirective\"),\n  require(\"./ast/do\"),\n  require(\"./ast/echo\"),\n  require(\"./ast/empty\"),\n  require(\"./ast/encapsed\"),\n  require(\"./ast/encapsedpart\"),\n  require(\"./ast/entry\"),\n  require(\"./ast/error\"),\n  require(\"./ast/eval\"),\n  require(\"./ast/exit\"),\n  require(\"./ast/expression\"),\n  require(\"./ast/expressionstatement\"),\n  require(\"./ast/for\"),\n  require(\"./ast/foreach\"),\n  require(\"./ast/function\"),\n  require(\"./ast/global\"),\n  require(\"./ast/goto\"),\n  require(\"./ast/halt\"),\n  require(\"./ast/identifier\"),\n  require(\"./ast/if\"),\n  require(\"./ast/include\"),\n  require(\"./ast/inline\"),\n  require(\"./ast/interface\"),\n  require(\"./ast/isset\"),\n  require(\"./ast/label\"),\n  require(\"./ast/list\"),\n  require(\"./ast/literal\"),\n  require(\"./ast/lookup\"),\n  require(\"./ast/magic\"),\n  require(\"./ast/method\"),\n  require(\"./ast/name\"),\n  require(\"./ast/namespace\"),\n  require(\"./ast/new\"),\n  require(\"./ast/node\"),\n  require(\"./ast/noop\"),\n  require(\"./ast/nowdoc\"),\n  require(\"./ast/nullkeyword\"),\n  require(\"./ast/number\"),\n  require(\"./ast/offsetlookup\"),\n  require(\"./ast/operation\"),\n  require(\"./ast/parameter\"),\n  require(\"./ast/parentreference\"),\n  require(\"./ast/post\"),\n  require(\"./ast/pre\"),\n  require(\"./ast/print\"),\n  require(\"./ast/program\"),\n  require(\"./ast/property\"),\n  require(\"./ast/propertylookup\"),\n  require(\"./ast/propertystatement\"),\n  require(\"./ast/reference\"),\n  require(\"./ast/retif\"),\n  require(\"./ast/return\"),\n  require(\"./ast/selfreference\"),\n  require(\"./ast/silent\"),\n  require(\"./ast/statement\"),\n  require(\"./ast/static\"),\n  require(\"./ast/staticvariable\"),\n  require(\"./ast/staticlookup\"),\n  require(\"./ast/staticreference\"),\n  require(\"./ast/string\"),\n  require(\"./ast/switch\"),\n  require(\"./ast/throw\"),\n  require(\"./ast/trait\"),\n  require(\"./ast/traitalias\"),\n  require(\"./ast/traitprecedence\"),\n  require(\"./ast/traituse\"),\n  require(\"./ast/try\"),\n  require(\"./ast/typereference\"),\n  require(\"./ast/unary\"),\n  require(\"./ast/unset\"),\n  require(\"./ast/usegroup\"),\n  require(\"./ast/useitem\"),\n  require(\"./ast/variable\"),\n  require(\"./ast/variadic\"),\n  require(\"./ast/while\"),\n  require(\"./ast/yield\"),\n  require(\"./ast/yieldfrom\"),\n].forEach(function (ctor) {\n  AST.prototype[ctor.kind] = ctor;\n});\n\nmodule.exports = AST;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expr = require(\"./expression\");\nconst KIND = \"array\";\n\n/**\n * Defines an array structure\n * @constructor Array\n * @example\n * // PHP code :\n * [1, 'foo' => 'bar', 3]\n *\n * // AST structure :\n * {\n *  \"kind\": \"array\",\n *  \"shortForm\": true\n *  \"items\": [\n *    {\"kind\": \"number\", \"value\": \"1\"},\n *    {\n *      \"kind\": \"entry\",\n *      \"key\": {\"kind\": \"string\", \"value\": \"foo\", \"isDoubleQuote\": false},\n *      \"value\": {\"kind\": \"string\", \"value\": \"bar\", \"isDoubleQuote\": false}\n *    },\n *    {\"kind\": \"number\", \"value\": \"3\"}\n *  ]\n * }\n * @extends {Expression}\n * @property {Entry|Expr|Variable} items List of array items\n * @property {boolean} shortForm Indicate if the short array syntax is used, ex `[]` instead `array()`\n */\nmodule.exports = Expr.extends(KIND, function Array(\n  shortForm,\n  items,\n  docs,\n  location\n) {\n  Expr.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"arrowfunc\";\n\n/**\n * Defines an arrow function (it's like a closure)\n * @constructor ArrowFunc\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {Expression} body\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {boolean} isStatic\n */\nmodule.exports = Expression.extends(KIND, function Closure(\n  args,\n  byref,\n  body,\n  type,\n  nullable,\n  isStatic,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.body = body;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"assign\";\n\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\nmodule.exports = Expression.extends(KIND, function Assign(\n  left,\n  right,\n  operator,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n  this.operator = operator;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"assignref\";\n\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\nmodule.exports = Expression.extends(KIND, function AssignRef(\n  left,\n  right,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Operation = require(\"./operation\");\nconst KIND = \"bin\";\n/**\n * Binary operations\n * @constructor Bin\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} left\n * @property {Expression} right\n */\nmodule.exports = Operation.extends(KIND, function Bin(\n  type,\n  left,\n  right,\n  docs,\n  location\n) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.left = left;\n  this.right = right;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"block\";\n\n/**\n * A block statement, i.e., a sequence of statements surrounded by braces.\n * @constructor Block\n * @extends {Statement}\n * @property {Node[]} children\n */\nmodule.exports = Statement.extends(KIND, function Block(\n  kind,\n  children,\n  docs,\n  location\n) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.children = children.filter(Boolean);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"boolean\";\n\n/**\n * Defines a boolean value (true/false)\n * @constructor Boolean\n * @extends {Literal}\n */\nmodule.exports = Literal.extends(KIND, function Boolean(\n  value,\n  raw,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"break\";\n\n/**\n * A break statement\n * @constructor Break\n * @extends {Statement}\n * @property {Number|Null} level\n */\nmodule.exports = Statement.extends(KIND, function Break(level, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"byref\";\n\n/**\n * Passing by Reference - so the function can modify the variable\n * @constructor ByRef\n * @extends {Expression}\n * @property {expr} what\n */\nmodule.exports = Expression.extends(KIND, function ByRef(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"call\";\n\n/**\n * Executes a call statement\n * @constructor Call\n * @extends {Expression}\n * @property {Identifier|Variable|??} what\n * @property {Arguments[]} arguments\n */\nmodule.exports = Expression.extends(KIND, function Call(\n  what,\n  args,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"case\";\n\n/**\n * A switch case statement\n * @constructor Case\n * @extends {Statement}\n * @property {Expression|null} test - if null, means that the default case\n * @property {Block|null} body\n */\nmodule.exports = Statement.extends(KIND, function Case(\n  test,\n  body,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Operation = require(\"./operation\");\nconst KIND = \"cast\";\n\n/**\n * Binary operations\n * @constructor Cast\n * @extends {Operation}\n * @property {String} type\n * @property {String} raw\n * @property {Expression} expr\n */\nmodule.exports = Operation.extends(KIND, function Cast(\n  type,\n  raw,\n  expr,\n  docs,\n  location\n) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.raw = raw;\n  this.expr = expr;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"catch\";\n\n/**\n * Defines a catch statement\n * @constructor Catch\n * @extends {Statement}\n * @property {Identifier[]} what\n * @property {Variable} variable\n * @property {Statement} body\n * @see http://php.net/manual/en/language.exceptions.php\n */\nmodule.exports = Statement.extends(KIND, function Catch(\n  body,\n  what,\n  variable,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.what = what;\n  this.variable = variable;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Declaration = require(\"./declaration\");\nconst KIND = \"class\";\n\n/**\n * A class definition\n * @constructor Class\n * @extends {Declaration}\n * @property {Identifier|null} extends\n * @property {Identifier[]} implements\n * @property {Declaration[]} body\n * @property {boolean} isAnonymous\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n */\nmodule.exports = Declaration.extends(KIND, function Class(\n  name,\n  ext,\n  impl,\n  body,\n  flags,\n  docs,\n  location\n) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.isAnonymous = name ? false : true;\n  this.extends = ext;\n  this.implements = impl;\n  this.body = body;\n  this.parseFlags(flags);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst ConstantStatement = require(\"./constantstatement\");\nconst KIND = \"classconstant\";\n\nconst IS_UNDEFINED = \"\";\nconst IS_PUBLIC = \"public\";\nconst IS_PROTECTED = \"protected\";\nconst IS_PRIVATE = \"private\";\n\n/**\n * Defines a class/interface/trait constant\n * @constructor ClassConstant\n * @extends {ConstantStatement}\n * @property {string} visibility\n */\nconst ClassConstant = ConstantStatement.extends(KIND, function ClassConstant(\n  kind,\n  constants,\n  flags,\n  docs,\n  location\n) {\n  ConstantStatement.apply(this, [kind || KIND, constants, docs, location]);\n  this.parseFlags(flags);\n});\n\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\nClassConstant.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n};\n\nmodule.exports = ClassConstant;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"clone\";\n\n/**\n * Defines a clone call\n * @constructor Clone\n * @extends {Expression}\n * @property {Expression} what\n */\nmodule.exports = Expression.extends(KIND, function Clone(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"closure\";\n\n/**\n * Defines a closure\n * @constructor Closure\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Variable[]} uses\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n * @property {boolean} isStatic\n */\nmodule.exports = Expression.extends(KIND, function Closure(\n  args,\n  byref,\n  uses,\n  type,\n  nullable,\n  isStatic,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.uses = uses;\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n  this.body = null;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\n\n/**\n * Abstract documentation node (ComentLine or CommentBlock)\n * @constructor Comment\n * @extends {Node}\n * @property {String} value\n */\nmodule.exports = Node.extends(\"comment\", function Comment(\n  kind,\n  value,\n  docs,\n  location\n) {\n  Node.apply(this, [kind, docs, location]);\n  this.value = value;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Comment = require(\"./comment\");\nconst KIND = \"commentblock\";\n\n/**\n * A comment block (multiline)\n * @constructor CommentBlock\n * @extends {Comment}\n */\nmodule.exports = Comment.extends(KIND, function CommentBlock(\n  value,\n  docs,\n  location\n) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Comment = require(\"./comment\");\nconst KIND = \"commentline\";\n\n/**\n * A single line comment\n * @constructor CommentLine\n * @extends {Comment}\n */\nmodule.exports = Comment.extends(KIND, function CommentLine(\n  value,\n  docs,\n  location\n) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"constant\";\n\n/**\n * Defines a constant\n * @constructor Constant\n * @extends {Node}\n * @property {string} name\n * @property {Node|string|number|boolean|null} value\n */\nmodule.exports = Node.extends(KIND, function Constant(\n  name,\n  value,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"constantstatement\";\n\n/**\n * Declares a constants into the current scope\n * @constructor ConstantStatement\n * @extends {Statement}\n * @property {Constant[]} constants\n */\nmodule.exports = Statement.extends(KIND, function ConstantStatement(\n  kind,\n  constants,\n  docs,\n  location\n) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.constants = constants;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"continue\";\n\n/**\n * A continue statement\n * @constructor Continue\n * @extends {Statement}\n * @property {Number|Null} level\n */\nmodule.exports = Statement.extends(KIND, function Continue(\n  level,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"declaration\";\n\nconst IS_UNDEFINED = \"\";\nconst IS_PUBLIC = \"public\";\nconst IS_PROTECTED = \"protected\";\nconst IS_PRIVATE = \"private\";\n\n/**\n * A declaration statement (function, class, interface...)\n * @constructor Declaration\n * @extends {Statement}\n * @property {Identifier|string} name\n */\nconst Declaration = Statement.extends(KIND, function Declaration(\n  kind,\n  name,\n  docs,\n  location\n) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.name = name;\n});\n\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\nDeclaration.prototype.parseFlags = function (flags) {\n  this.isAbstract = flags[2] === 1;\n  this.isFinal = flags[2] === 2;\n  if (this.kind !== \"class\") {\n    if (flags[0] === -1) {\n      this.visibility = IS_UNDEFINED;\n    } else if (flags[0] === null) {\n      this.visibility = null;\n    } else if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n    this.isStatic = flags[1] === 1;\n  }\n};\n\nmodule.exports = Declaration;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Block = require(\"./block\");\nconst KIND = \"declare\";\n\n/**\n * The declare construct is used to set execution directives for a block of code\n * @constructor Declare\n * @extends {Block}\n * @property {Array[]} directives\n * @property {String} mode\n * @see http://php.net/manual/en/control-structures.declare.php\n */\nconst Declare = Block.extends(KIND, function Declare(\n  directives,\n  body,\n  mode,\n  docs,\n  location\n) {\n  Block.apply(this, [KIND, body, docs, location]);\n  this.directives = directives;\n  this.mode = mode;\n});\n\n/**\n * The node is declared as a short tag syntax :\n * ```php\n * <?php\n * declare(ticks=1):\n * // some statements\n * enddeclare;\n * ```\n * @constant {String} MODE_SHORT\n */\nDeclare.MODE_SHORT = \"short\";\n\n/**\n * The node is declared bracket enclosed code :\n * ```php\n * <?php\n * declare(ticks=1) {\n * // some statements\n * }\n * ```\n * @constant {String} MODE_BLOCK\n */\nDeclare.MODE_BLOCK = \"block\";\n\n/**\n * The node is declared as a simple statement. In order to make things simpler\n * children of the node are automatically collected until the next\n * declare statement.\n * ```php\n * <?php\n * declare(ticks=1);\n * // some statements\n * declare(ticks=2);\n * // some statements\n * ```\n * @constant {String} MODE_NONE\n */\nDeclare.MODE_NONE = \"none\";\n\nmodule.exports = Declare;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"declaredirective\";\n\n/**\n * Defines a constant\n * @constructor DeclareDirective\n * @extends {Node}\n * @property {Identifier} name\n * @property {Node|string|number|boolean|null} value\n */\nmodule.exports = Node.extends(KIND, function DeclareDirective(\n  key,\n  value,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"do\";\n\n/**\n * Defines a do/while statement\n * @constructor Do\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n */\nmodule.exports = Statement.extends(KIND, function Do(\n  test,\n  body,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"echo\";\n\n/**\n * Defines system based call\n * @constructor Echo\n * @property {boolean} shortForm\n * @extends {Statement}\n */\nmodule.exports = Statement.extends(KIND, function Echo(\n  expressions,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.shortForm = shortForm;\n  this.expressions = expressions;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"empty\";\n\n/**\n * Defines an empty check call\n * @constructor Empty\n * @extends {Expression}\n */\nmodule.exports = Expression.extends(KIND, function Empty(\n  expression,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"encapsed\";\n\n/**\n * Defines an encapsed string (contains expressions)\n * @constructor Encapsed\n * @extends {Literal}\n * @property {String} type - Defines the type of encapsed string (shell, heredoc, string)\n * @property {String|Null} label - The heredoc label, defined only when the type is heredoc\n */\nconst Encapsed = Literal.extends(KIND, function Encapsed(\n  value,\n  raw,\n  type,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.type = type;\n});\n\n/**\n * The node is a double quote string :\n * ```php\n * <?php\n * echo \"hello $world\";\n * ```\n * @constant {String} TYPE_STRING - `string`\n */\nEncapsed.TYPE_STRING = \"string\";\n\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo `ls -larth $path`;\n * ```\n * @constant {String} TYPE_SHELL - `shell`\n */\nEncapsed.TYPE_SHELL = \"shell\";\n\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo <<<STR\n *  Hello $world\n * STR\n * ;\n * ```\n * @constant {String} TYPE_HEREDOC - `heredoc`\n */\nEncapsed.TYPE_HEREDOC = \"heredoc\";\n\n/**\n * The node contains a list of constref / variables / expr :\n * ```php\n * <?php\n * echo $foo->bar_$baz;\n * ```\n * @constant {String} TYPE_OFFSET - `offset`\n */\nEncapsed.TYPE_OFFSET = \"offset\";\n\nmodule.exports = Encapsed;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"encapsedpart\";\n\n/**\n * Part of `Encapsed` node\n * @constructor EncapsedPart\n * @extends {Expression}\n * @property {Expression} expression\n * @property {String} syntax\n * @property {Boolean} curly\n */\nmodule.exports = Expression.extends(KIND, function EncapsedPart(\n  expression,\n  syntax,\n  curly,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.syntax = syntax;\n  this.curly = curly;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"entry\";\n\n/**\n * An array entry - see [Array](#array)\n * @constructor Entry\n * @extends {Expression}\n * @property {Node|null} key The entry key/offset\n * @property {Node} value The entry value\n * @property {Boolean} byRef By reference\n * @property {Boolean} unpack Argument unpacking\n */\nmodule.exports = Expression.extends(KIND, function Entry(\n  key,\n  value,\n  byRef,\n  unpack,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n  this.byRef = byRef;\n  this.unpack = unpack;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"error\";\n\n/**\n * Defines an error node (used only on silentMode)\n * @constructor Error\n * @extends {Node}\n * @property {string} message\n * @property {number} line\n * @property {number|string} token\n * @property {string|array} expected\n */\nmodule.exports = Node.extends(KIND, function Error(\n  message,\n  token,\n  line,\n  expected,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.message = message;\n  this.token = token;\n  this.line = line;\n  this.expected = expected;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"eval\";\n\n/**\n * Defines an eval statement\n * @constructor Eval\n * @extends {Expression}\n * @property {Node} source\n */\nmodule.exports = Expression.extends(KIND, function Eval(\n  source,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.source = source;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"exit\";\n\n/**\n * Defines an exit / die call\n * @constructor Exit\n * @extends {Expression}\n * @property {Node|null} expression\n * @property {Boolean} useDie\n */\nmodule.exports = Expression.extends(KIND, function Exit(\n  expression,\n  useDie,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.useDie = useDie;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"expression\";\n\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Expression\n * @extends {Node}\n */\nmodule.exports = Node.extends(KIND, function Expression(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"expressionstatement\";\n\n/**\n * Defines an expression based statement\n * @constructor ExpressionStatement\n * @extends {Statement}\n * @property {Expression} expression\n */\nmodule.exports = Statement.extends(KIND, function ExpressionStatement(\n  expr,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expression = expr;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"for\";\n\n/**\n * Defines a for iterator\n * @constructor For\n * @extends {Statement}\n * @property {Expression[]} init\n * @property {Expression[]} test\n * @property {Expression[]} increment\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.for.php\n */\nmodule.exports = Statement.extends(KIND, function For(\n  init,\n  test,\n  increment,\n  body,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.init = init;\n  this.test = test;\n  this.increment = increment;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"foreach\";\n\n/**\n * Defines a foreach iterator\n * @constructor Foreach\n * @extends {Statement}\n * @property {Expression} source\n * @property {Expression|null} key\n * @property {Expression} value\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.foreach.php\n */\nmodule.exports = Statement.extends(KIND, function Foreach(\n  source,\n  key,\n  value,\n  body,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.source = source;\n  this.key = key;\n  this.value = value;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Declaration = require(\"./declaration\");\nconst KIND = \"function\";\n\n/**\n * Defines a classic function\n * @constructor Function\n * @extends {Declaration}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n */\nmodule.exports = Declaration.extends(KIND, function _Function(\n  name,\n  args,\n  byref,\n  type,\n  nullable,\n  docs,\n  location\n) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.body = null;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"global\";\n\n/**\n * Imports a variable from the global scope\n * @constructor Global\n * @extends {Statement}\n * @property {Variable[]} items\n */\nmodule.exports = Statement.extends(KIND, function Global(\n  items,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.items = items;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"goto\";\n\n/**\n * Defines goto statement\n * @constructor Goto\n * @extends {Statement}\n * @property {String} label\n * @see {Label}\n */\nmodule.exports = Statement.extends(KIND, function Goto(label, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.label = label;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"halt\";\n\n/**\n * Halts the compiler execution\n * @constructor Halt\n * @extends {Statement}\n * @property {String} after - String after the halt statement\n * @see http://php.net/manual/en/function.halt-compiler.php\n */\nmodule.exports = Statement.extends(KIND, function Halt(after, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.after = after;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"identifier\";\n\n/**\n * Defines an identifier node\n * @constructor Identifier\n * @extends {Node}\n * @property {string} name\n */\nconst Identifier = Node.extends(KIND, function Identifier(\n  name,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\n\nmodule.exports = Identifier;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"if\";\n\n/**\n * Defines a if statement\n * @constructor If\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {Block|If|null} alternate\n * @property {boolean} shortForm\n */\nmodule.exports = Statement.extends(KIND, function If(\n  test,\n  body,\n  alternate,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.alternate = alternate;\n  this.shortForm = shortForm;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"include\";\n\n/**\n * Defines system include call\n * @constructor Include\n * @extends {Expression}\n * @property {Node} target\n * @property {boolean} once\n * @property {boolean} require\n */\nmodule.exports = Expression.extends(KIND, function Include(\n  once,\n  require,\n  target,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.once = once;\n  this.require = require;\n  this.target = target;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"inline\";\n\n/**\n * Defines inline html output (treated as echo output)\n * @constructor Inline\n * @extends {Literal}\n */\nmodule.exports = Literal.extends(KIND, function Inline(\n  value,\n  raw,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Declaration = require(\"./declaration\");\nconst KIND = \"interface\";\n\n/**\n * An interface definition\n * @constructor Interface\n * @extends {Declaration}\n * @property {Identifier[]} extends\n * @property {Declaration[]} body\n */\nmodule.exports = Declaration.extends(KIND, function Interface(\n  name,\n  ext,\n  body,\n  docs,\n  location\n) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.extends = ext;\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"isset\";\n\n/**\n * Defines an isset call\n * @constructor Isset\n * @extends {Expression}\n */\nmodule.exports = Expression.extends(KIND, function Isset(\n  variables,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"label\";\n\n/**\n * A label statement (referenced by goto)\n * @constructor Label\n * @extends {Statement}\n * @property {String} name\n */\nmodule.exports = Statement.extends(KIND, function Label(name, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"list\";\n\n/**\n * Defines list assignment\n * @constructor List\n * @extends {Expression}\n * @property {boolean} shortForm\n */\nmodule.exports = Expression.extends(KIND, function List(\n  items,\n  shortForm,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"literal\";\n\n/**\n * Defines an array structure\n * @constructor Literal\n * @extends {Expression}\n * @property {string} raw\n * @property {Node|string|number|boolean|null} value\n */\nmodule.exports = Expression.extends(KIND, function Literal(\n  kind,\n  value,\n  raw,\n  docs,\n  location\n) {\n  Expression.apply(this, [kind || KIND, docs, location]);\n  this.value = value;\n  if (raw) {\n    this.raw = raw;\n  }\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * Defines the location of the node (with it's source contents as string)\n * @constructor Location\n * @property {String|null} source\n * @property {Position} start\n * @property {Position} end\n */\nconst Location = function (source, start, end) {\n  this.source = source;\n  this.start = start;\n  this.end = end;\n};\n\nmodule.exports = Location;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expr = require(\"./expression\");\nconst KIND = \"lookup\";\n\n/**\n * Lookup on an offset in the specified object\n * @constructor Lookup\n * @extends {Expression}\n * @property {Expression} what\n * @property {Expression} offset\n */\nmodule.exports = Expr.extends(KIND, function Lookup(\n  kind,\n  what,\n  offset,\n  docs,\n  location\n) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n  this.what = what;\n  this.offset = offset;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"magic\";\n\n/**\n * Defines magic constant\n * @constructor Magic\n * @extends {Literal}\n */\nmodule.exports = Literal.extends(KIND, function Magic(\n  value,\n  raw,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst _Function = require(\"./function\");\nconst KIND = \"method\";\n\n/**\n * Defines a class/interface/trait method\n * @constructor Method\n * @extends {_Function}\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n * @property {boolean} isStatic\n * @property {string} visibility\n */\nmodule.exports = _Function.extends(KIND, function Method() {\n  _Function.apply(this, arguments);\n  this.kind = KIND;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Reference = require(\"./reference\");\nconst KIND = \"name\";\n\n/**\n * Defines a class reference node\n * @constructor Name\n * @extends {Reference}\n * @property {string} name\n * @property {string} resolution\n */\nconst Name = Reference.extends(KIND, function Name(\n  name,\n  isRelative,\n  docs,\n  location\n) {\n  Reference.apply(this, [KIND, docs, location]);\n  if (isRelative) {\n    this.resolution = Name.RELATIVE_NAME;\n  } else if (name.length === 1) {\n    this.resolution = Name.UNQUALIFIED_NAME;\n  } else if (!name[0]) {\n    this.resolution = Name.FULL_QUALIFIED_NAME;\n  } else {\n    this.resolution = Name.QUALIFIED_NAME;\n  }\n  this.name = name.join(\"\\\\\");\n});\n\n/**\n * This is an identifier without a namespace separator, such as Foo\n * @constant {String} UNQUALIFIED_NAME\n */\nName.UNQUALIFIED_NAME = \"uqn\";\n/**\n * This is an identifier with a namespace separator, such as Foo\\Bar\n * @constant {String} QUALIFIED_NAME\n */\nName.QUALIFIED_NAME = \"qn\";\n/**\n * This is an identifier with a namespace separator that begins with\n * a namespace separator, such as \\Foo\\Bar. The namespace \\Foo is also\n * a fully qualified name.\n * @constant {String} FULL_QUALIFIED_NAME\n */\nName.FULL_QUALIFIED_NAME = \"fqn\";\n/**\n * This is an identifier starting with namespace, such as namespace\\Foo\\Bar.\n * @constant {String} RELATIVE_NAME\n */\nName.RELATIVE_NAME = \"rn\";\n\nmodule.exports = Name;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Block = require(\"./block\");\nconst KIND = \"namespace\";\n\n/**\n * The main program node\n * @constructor Namespace\n * @extends {Block}\n * @property {String} name\n * @property {Boolean} withBrackets\n */\nmodule.exports = Block.extends(KIND, function Namespace(\n  name,\n  children,\n  withBrackets,\n  docs,\n  location\n) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.name = name;\n  this.withBrackets = withBrackets || false;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"new\";\n\n/**\n * Creates a new instance of the specified class\n * @constructor New\n * @extends {Expression}\n * @property {Identifier|Variable|Class} what\n * @property {Arguments[]} arguments\n */\nmodule.exports = Expression.extends(KIND, function New(\n  what,\n  args,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * A generic AST node\n * @constructor Node\n * @property {Location|null} loc\n * @property {Comment[]} leadingComments\n * @property {Comment[]?} trailingComments\n * @property {String} kind\n */\nconst Node = function Node(kind, docs, location) {\n  this.kind = kind;\n  if (docs) {\n    this.leadingComments = docs;\n  }\n  if (location) {\n    this.loc = location;\n  }\n};\n\n/**\n * Attach comments to current node\n * @param {*} docs\n */\nNode.prototype.setTrailingComments = function (docs) {\n  this.trailingComments = docs;\n};\n\n/**\n * Destroying an unused node\n */\nNode.prototype.destroy = function (node) {\n  if (!node) {\n    throw new Error(\n      \"Node already initialized, you must swap with another node\"\n    );\n  }\n  if (this.leadingComments) {\n    if (node.leadingComments) {\n      node.leadingComments = Array.concat(\n        this.leadingComments,\n        node.leadingComments\n      );\n    } else {\n      node.leadingComments = this.leadingComments;\n    }\n  }\n  if (this.trailingComments) {\n    if (node.trailingComments) {\n      node.trailingComments = Array.concat(\n        this.trailingComments,\n        node.trailingComments\n      );\n    } else {\n      node.trailingComments = this.trailingComments;\n    }\n  }\n  return node;\n};\n\n/**\n * Includes current token position of the parser\n * @param {*} parser\n */\nNode.prototype.includeToken = function (parser) {\n  if (this.loc) {\n    if (this.loc.end) {\n      this.loc.end.line = parser.lexer.yylloc.last_line;\n      this.loc.end.column = parser.lexer.yylloc.last_column;\n      this.loc.end.offset = parser.lexer.offset;\n    }\n    if (parser.ast.withSource) {\n      this.loc.source = parser.lexer._input.substring(\n        this.loc.start.offset,\n        parser.lexer.offset\n      );\n    }\n  }\n  return this;\n};\n\n/**\n * Helper for extending the Node class\n * @param {String} type\n * @param {Function} constructor\n * @return {Function}\n */\nNode.extends = function (type, constructor) {\n  constructor.prototype = Object.create(this.prototype);\n  constructor.extends = this.extends;\n  constructor.prototype.constructor = constructor;\n  constructor.kind = type;\n  return constructor;\n};\n\nmodule.exports = Node;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"noop\";\n\n/**\n * Ignore this node, it implies a no operation block, for example :\n * [$foo, $bar, /* here a noop node * /]\n * @constructor Noop\n * @extends {Node}\n */\nmodule.exports = Node.extends(KIND, function Noop(docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"nowdoc\";\n\n/**\n * Defines a nowdoc string\n * @constructor NowDoc\n * @extends {Literal}\n * @property {String} label\n * @property {String} raw\n */\nmodule.exports = Literal.extends(KIND, function Nowdoc(\n  value,\n  raw,\n  label,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.label = label;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"nullkeyword\";\n\n/**\n * Represents the null keyword\n * @constructor NullKeyword\n * @extends {Node}\n */\nmodule.exports = Node.extends(KIND, function NullKeyword(raw, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"number\";\n\n/**\n * Defines a numeric value\n * @constructor Number\n * @extends {Literal}\n */\nmodule.exports = Literal.extends(KIND, function Number(\n  value,\n  raw,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Lookup = require(\"./lookup\");\nconst KIND = \"offsetlookup\";\n\n/**\n * Lookup on an offset in an array\n * @constructor OffsetLookup\n * @extends {Lookup}\n */\nmodule.exports = Lookup.extends(KIND, function OffsetLookup(\n  what,\n  offset,\n  docs,\n  location\n) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expr = require(\"./expression\");\nconst KIND = \"operation\";\n\n/**\n * Defines binary operations\n * @constructor Operation\n * @extends {Expression}\n */\nmodule.exports = Expr.extends(KIND, function Operation(kind, docs, location) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Declaration = require(\"./declaration\");\nconst KIND = \"parameter\";\n\n/**\n * Defines a function parameter\n * @constructor Parameter\n * @extends {Declaration}\n * @property {Identifier|null} type\n * @property {Node|null} value\n * @property {boolean} byref\n * @property {boolean} variadic\n * @property {boolean} nullable\n */\nmodule.exports = Declaration.extends(KIND, function Parameter(\n  name,\n  type,\n  value,\n  isRef,\n  isVariadic,\n  nullable,\n  docs,\n  location\n) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.value = value;\n  this.type = type;\n  this.byref = isRef;\n  this.variadic = isVariadic;\n  this.nullable = nullable;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Reference = require(\"./reference\");\nconst KIND = \"parentreference\";\n\n/**\n * Defines a class reference node\n * @constructor ParentReference\n * @extends {Reference}\n */\nconst ParentReference = Reference.extends(KIND, function ParentReference(\n  raw,\n  docs,\n  location\n) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = ParentReference;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * Each Position object consists of a line number (1-indexed) and a column number (0-indexed):\n * @constructor Position\n * @property {Number} line\n * @property {Number} column\n * @property {Number} offset\n */\nconst Position = function (line, column, offset) {\n  this.line = line;\n  this.column = column;\n  this.offset = offset;\n};\n\nmodule.exports = Position;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Operation = require(\"./operation\");\nconst KIND = \"post\";\n\n/**\n * Defines a post operation `$i++` or `$i--`\n * @constructor Post\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\nmodule.exports = Operation.extends(KIND, function Post(\n  type,\n  what,\n  docs,\n  location\n) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Operation = require(\"./operation\");\nconst KIND = \"pre\";\n\n/**\n * Defines a pre operation `++$i` or `--$i`\n * @constructor Pre\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\nmodule.exports = Operation.extends(KIND, function Pre(\n  type,\n  what,\n  docs,\n  location\n) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"print\";\n\n/**\n * Outputs\n * @constructor Print\n * @extends {Expression}\n */\nmodule.exports = Expression.extends(KIND, function Print(\n  expression,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Block = require(\"./block\");\nconst KIND = \"program\";\n\n/**\n * The main program node\n * @constructor Program\n * @extends {Block}\n * @property {Error[]} errors\n * @property {Doc[]?} comments\n * @property {String[]?} tokens\n */\nmodule.exports = Block.extends(KIND, function Program(\n  children,\n  errors,\n  comments,\n  tokens,\n  docs,\n  location\n) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.errors = errors;\n  if (comments) {\n    this.comments = comments;\n  }\n  if (tokens) {\n    this.tokens = tokens;\n  }\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"property\";\n\n/**\n * Defines a class property\n * @constructor Property\n * @extends {Statement}\n * @property {string} name\n * @property {Node|null} value\n * @property {boolean} nullable\n * @property {Identifier|Array<Identifier>|null} type\n */\nmodule.exports = Statement.extends(KIND, function Property(\n  name,\n  value,\n  nullable,\n  type,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n  this.nullable = nullable;\n  this.type = type;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Lookup = require(\"./lookup\");\nconst KIND = \"propertylookup\";\n\n/**\n * Lookup to an object property\n * @constructor PropertyLookup\n * @extends {Lookup}\n */\nmodule.exports = Lookup.extends(KIND, function PropertyLookup(\n  what,\n  offset,\n  docs,\n  location\n) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"propertystatement\";\n\nconst IS_UNDEFINED = \"\";\nconst IS_PUBLIC = \"public\";\nconst IS_PROTECTED = \"protected\";\nconst IS_PRIVATE = \"private\";\n\n/**\n * Declares a properties into the current scope\n * @constructor PropertyStatement\n * @extends {Statement}\n * @property {Property[]} properties\n */\nconst PropertyStatement = Statement.extends(KIND, function PropertyStatement(\n  kind,\n  properties,\n  flags,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.properties = properties;\n  this.parseFlags(flags);\n});\n\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\nPropertyStatement.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n\n  this.isStatic = flags[1] === 1;\n};\n\nmodule.exports = PropertyStatement;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"reference\";\n\n/**\n * Defines a reference node\n * @constructor Reference\n * @extends {Node}\n */\nconst Reference = Node.extends(KIND, function Reference(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n\nmodule.exports = Reference;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"retif\";\n\n/**\n * Defines a short if statement that returns a value\n * @constructor RetIf\n * @extends {Expression}\n * @property {Expression} test\n * @property {Expression} trueExpr\n * @property {Expression} falseExpr\n */\nmodule.exports = Expression.extends(KIND, function RetIf(\n  test,\n  trueExpr,\n  falseExpr,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.trueExpr = trueExpr;\n  this.falseExpr = falseExpr;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"return\";\n\n/**\n * A continue statement\n * @constructor Return\n * @extends {Statement}\n * @property {Expression|null} expr\n */\nmodule.exports = Statement.extends(KIND, function Return(expr, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Reference = require(\"./reference\");\nconst KIND = \"selfreference\";\n\n/**\n * Defines a class reference node\n * @constructor SelfReference\n * @extends {Reference}\n */\nconst SelfReference = Reference.extends(KIND, function SelfReference(\n  raw,\n  docs,\n  location\n) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = SelfReference;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"silent\";\n\n/**\n * Avoids to show/log warnings & notices from the inner expression\n * @constructor Silent\n * @extends {Expression}\n * @property {Expression} expr\n */\nmodule.exports = Expression.extends(KIND, function Silent(\n  expr,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"statement\";\n\n/**\n * Any statement.\n * @constructor Statement\n * @extends {Node}\n */\nmodule.exports = Node.extends(KIND, function Statement(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"static\";\n\n/**\n * Declares a static variable into the current scope\n * @constructor Static\n * @extends {Statement}\n * @property {StaticVariable[]} variables\n */\nmodule.exports = Statement.extends(KIND, function Static(\n  variables,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Lookup = require(\"./lookup\");\nconst KIND = \"staticlookup\";\n\n/**\n * Lookup to a static property\n * @constructor StaticLookup\n * @extends {Lookup}\n */\nmodule.exports = Lookup.extends(KIND, function StaticLookup(\n  what,\n  offset,\n  docs,\n  location\n) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Reference = require(\"./reference\");\nconst KIND = \"staticreference\";\n\n/**\n * Defines a class reference node\n * @constructor StaticReference\n * @extends {Reference}\n */\nconst StaticReference = Reference.extends(KIND, function StaticReference(\n  raw,\n  docs,\n  location\n) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = StaticReference;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"staticvariable\";\n\n/**\n * Defines a constant\n * @constructor StaticVariable\n * @extends {Node}\n * @property {Variable} variable\n * @property {Node|string|number|boolean|null} defaultValue\n */\nmodule.exports = Node.extends(KIND, function StaticVariable(\n  variable,\n  defaultValue,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.variable = variable;\n  this.defaultValue = defaultValue;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Literal = require(\"./literal\");\nconst KIND = \"string\";\n\n/**\n * Defines a string (simple ou double quoted) - chars are already escaped\n * @constructor String\n * @extends {Literal}\n * @property {boolean} unicode\n * @property {boolean} isDoubleQuote\n * @see {Encapsed}\n */\nmodule.exports = Literal.extends(KIND, function String(\n  isDoubleQuote,\n  value,\n  unicode,\n  raw,\n  docs,\n  location\n) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.unicode = unicode;\n  this.isDoubleQuote = isDoubleQuote;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"switch\";\n\n/**\n * Defines a switch statement\n * @constructor Switch\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {boolean} shortForm\n */\nmodule.exports = Statement.extends(KIND, function Switch(\n  test,\n  body,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"throw\";\n\n/**\n * Defines a throw statement\n * @constructor Throw\n * @extends {Statement}\n * @property {Expression} what\n */\nmodule.exports = Statement.extends(KIND, function Throw(what, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Declaration = require(\"./declaration\");\nconst KIND = \"trait\";\n\n/**\n * A trait definition\n * @constructor Trait\n * @extends {Declaration}\n * @property {Declaration[]} body\n */\nmodule.exports = Declaration.extends(KIND, function Trait(\n  name,\n  body,\n  docs,\n  location\n) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.body = body;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"traitalias\";\n\nconst IS_UNDEFINED = \"\";\nconst IS_PUBLIC = \"public\";\nconst IS_PROTECTED = \"protected\";\nconst IS_PRIVATE = \"private\";\n\n/**\n * Defines a trait alias\n * @constructor TraitAlias\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier|null} as\n * @property {string|null} visibility\n */\nmodule.exports = Node.extends(KIND, function TraitAlias(\n  trait,\n  method,\n  as,\n  flags,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.as = as;\n  this.visibility = IS_UNDEFINED;\n  if (flags) {\n    if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n  }\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"traitprecedence\";\n\n/**\n * Defines a trait alias\n * @constructor TraitPrecedence\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier[]} instead\n */\nmodule.exports = Node.extends(KIND, function TraitPrecedence(\n  trait,\n  method,\n  instead,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.instead = instead;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Node = require(\"./node\");\nconst KIND = \"traituse\";\n\n/**\n * Defines a trait usage\n * @constructor TraitUse\n * @extends {Node}\n * @property {Identifier[]} traits\n * @property {Node[]|null} adaptations\n */\nmodule.exports = Node.extends(KIND, function TraitUse(\n  traits,\n  adaptations,\n  docs,\n  location\n) {\n  Node.apply(this, [KIND, docs, location]);\n  this.traits = traits;\n  this.adaptations = adaptations;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"try\";\n\n/**\n * Defines a try statement\n * @constructor Try\n * @extends {Statement}\n * @property {Block} body\n * @property {Catch[]} catches\n * @property {Block} allways\n */\nmodule.exports = Statement.extends(KIND, function Try(\n  body,\n  catches,\n  always,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.catches = catches;\n  this.always = always;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Reference = require(\"./reference\");\nconst KIND = \"typereference\";\n\n/**\n * Defines a class reference node\n * @constructor TypeReference\n * @extends {Reference}\n * @property {string} name\n */\nconst TypeReference = Reference.extends(KIND, function TypeReference(\n  name,\n  raw,\n  docs,\n  location\n) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.raw = raw;\n});\n\nTypeReference.types = [\n  \"int\",\n  \"float\",\n  \"string\",\n  \"bool\",\n  \"object\",\n  \"array\",\n  \"callable\",\n  \"iterable\",\n  \"void\",\n];\n\nmodule.exports = TypeReference;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Operation = require(\"./operation\");\nconst KIND = \"unary\";\n\n/**\n * Unary operations\n * @constructor Unary\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} what\n */\nmodule.exports = Operation.extends(KIND, function Unary(\n  type,\n  what,\n  docs,\n  location\n) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"unset\";\n\n/**\n * Deletes references to a list of variables\n * @constructor Unset\n * @extends {Statement}\n */\nmodule.exports = Statement.extends(KIND, function Unset(\n  variables,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"usegroup\";\n\n/**\n * Defines a use statement (with a list of use items)\n * @constructor UseGroup\n * @extends {Statement}\n * @property {String|null} name\n * @property {String|null} type - Possible value : function, const\n * @property {UseItem[]} item\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\nmodule.exports = Statement.extends(KIND, function UseGroup(\n  name,\n  type,\n  items,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.type = type;\n  this.items = items;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"useitem\";\n\n/**\n * Defines a use statement (from namespace)\n * @constructor UseItem\n * @extends {Statement}\n * @property {String} name\n * @property {String|null} type - Possible value : function, const\n * @property {Identifier|null} alias\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\nconst UseItem = Statement.extends(KIND, function UseItem(\n  name,\n  alias,\n  type,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.alias = alias;\n  this.type = type;\n});\n\n/**\n * Importing a constant\n * @constant {String} TYPE_CONST\n */\nUseItem.TYPE_CONST = \"const\";\n/**\n * Importing a function\n * @constant {String} TYPE_FUNC\n */\nUseItem.TYPE_FUNCTION = \"function\";\n\nmodule.exports = UseItem;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"variable\";\n\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Variable\n * @extends {Expression}\n * @example\n * // PHP code :\n * $foo\n * // AST output\n * {\n *  \"kind\": \"variable\",\n *  \"name\": \"foo\",\n *  \"curly\": false\n * }\n * @property {String|Node} name The variable name (can be a complex expression when the name is resolved dynamically)\n * @property {boolean} curly Indicate if the name is defined between curlies, ex `${foo}`\n */\nmodule.exports = Expression.extends(KIND, function Variable(\n  name,\n  curly,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.curly = curly || false;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"variadic\";\n\n/**\n * Introduce a list of items into the arguments of the call\n * @constructor variadic\n * @extends {Expression}\n * @property {Array|Expression} what\n * @see https://wiki.php.net/rfc/argument_unpacking\n */\nmodule.exports = Expression.extends(KIND, function variadic(\n  what,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Statement = require(\"./statement\");\nconst KIND = \"while\";\n\n/**\n * Defines a while statement\n * @constructor While\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n * @property {boolean} shortForm\n */\nmodule.exports = Statement.extends(KIND, function While(\n  test,\n  body,\n  shortForm,\n  docs,\n  location\n) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"yield\";\n\n/**\n * Defines a yield generator statement\n * @constructor Yield\n * @extends {Expression}\n * @property {Expression|Null} value\n * @property {Expression|Null} key\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\nmodule.exports = Expression.extends(KIND, function Yield(\n  value,\n  key,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n  this.key = key;\n});\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst Expression = require(\"./expression\");\nconst KIND = \"yieldfrom\";\n\n/**\n * Defines a yield from generator statement\n * @constructor YieldFrom\n * @extends {Expression}\n * @property {Expression} value\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\nmodule.exports = Expression.extends(KIND, function YieldFrom(\n  value,\n  docs,\n  location\n) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n});\n","/**\n * Copyright (C) 2020 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst lexer = require(\"./lexer\");\nconst parser = require(\"./parser\");\nconst tokens = require(\"./tokens\");\nconst AST = require(\"./ast\");\n\n/**\n * @private\n */\nfunction combine(src, to) {\n  const keys = Object.keys(src);\n  let i = keys.length;\n  while (i--) {\n    const k = keys[i];\n    const val = src[k];\n    if (val === null) {\n      delete to[k];\n    } else if (typeof val === \"function\") {\n      to[k] = val.bind(to);\n    } else if (Array.isArray(val)) {\n      to[k] = Array.isArray(to[k]) ? to[k].concat(val) : val;\n    } else if (typeof val === \"object\") {\n      to[k] = typeof to[k] === \"object\" ? combine(val, to[k]) : val;\n    } else {\n      to[k] = val;\n    }\n  }\n  return to;\n}\n\n/**\n * Initialise a new parser instance with the specified options\n *\n * @class\n * @tutorial Engine\n * @example\n * var parser = require('php-parser');\n * var instance = new parser({\n *   parser: {\n *     extractDoc: true,\n *     suppressErrors: true,\n *     version: 704 // or '7.4'\n *   },\n *   ast: {\n *     withPositions: true\n *   },\n *   lexer: {\n *     short_tags: true,\n *     asp_tags: true\n *   }\n * });\n *\n * var evalAST = instance.parseEval('some php code');\n * var codeAST = instance.parseCode('<?php some php code', 'foo.php');\n * var tokens = instance.tokenGetAll('<?php some php code');\n *\n * @param {Object} options - List of options\n * @property {Lexer} lexer\n * @property {Parser} parser\n * @property {AST} ast\n * @property {Object} tokens\n */\nconst engine = function (options) {\n  if (typeof this === \"function\") {\n    return new this(options);\n  }\n  this.tokens = tokens;\n  this.lexer = new lexer(this);\n  this.ast = new AST();\n  this.parser = new parser(this.lexer, this.ast);\n  if (options && typeof options === \"object\") {\n    // disable php7 from lexer if already disabled from parser\n    if (options.parser) {\n      if (!options.lexer) {\n        options.lexer = {};\n      }\n      if (options.parser.version) {\n        if (typeof options.parser.version === \"string\") {\n          let version = options.parser.version.split(\".\");\n          version = parseInt(version[0]) * 100 + parseInt(version[1]);\n          if (isNaN(version)) {\n            throw new Error(\"Bad version number : \" + options.parser.version);\n          } else {\n            options.parser.version = version;\n          }\n        } else if (typeof options.parser.version !== \"number\") {\n          throw new Error(\"Expecting a number for version\");\n        }\n        if (options.parser.version < 500 || options.parser.version > 704) {\n          throw new Error(\"Can only handle versions between 5.x to 7.x\");\n        }\n      }\n    }\n    combine(options, this);\n\n    // same version flags based on parser options\n    this.lexer.version = this.parser.version;\n  }\n};\n\n/**\n * Check if the inpyt is a buffer or a string\n * @param  {Buffer|String} buffer Input value that can be either a buffer or a string\n * @return {String}   Returns the string from input\n */\nconst getStringBuffer = function (buffer) {\n  return typeof buffer.write === \"function\" ? buffer.toString() : buffer;\n};\n\n/**\n * Creates a new instance (Helper)\n * @param {Object} options\n * @return {Engine}\n * @private\n */\nengine.create = function (options) {\n  return new engine(options);\n};\n\n/**\n * Evaluate the buffer\n * @private\n */\nengine.parseEval = function (buffer, options) {\n  const self = new engine(options);\n  return self.parseEval(buffer);\n};\n\n/**\n * Parse an evaluating mode string (no need to open php tags)\n * @param {String} buffer\n * @return {Program}\n */\nengine.prototype.parseEval = function (buffer) {\n  this.lexer.mode_eval = true;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, \"eval\");\n};\n\n/**\n * Static function that parse a php code with open/close tags\n * @private\n */\nengine.parseCode = function (buffer, filename, options) {\n  if (typeof filename === \"object\" && !options) {\n    // retro-compatibility\n    options = filename;\n    filename = \"unknown\";\n  }\n  const self = new engine(options);\n  return self.parseCode(buffer, filename);\n};\n\n/**\n * Function that parse a php code with open/close tags\n *\n * Sample code :\n * ```php\n * <?php $x = 1;\n * ```\n *\n * Usage :\n * ```js\n * var parser = require('php-parser');\n * var phpParser = new parser({\n *   // some options\n * });\n * var ast = phpParser.parseCode('...php code...', 'foo.php');\n * ```\n * @param {String} buffer - The code to be parsed\n * @param {String} filename - Filename\n * @return {Program}\n */\nengine.prototype.parseCode = function (buffer, filename) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, filename);\n};\n\n/**\n * Split the buffer into tokens\n * @private\n */\nengine.tokenGetAll = function (buffer, options) {\n  const self = new engine(options);\n  return self.tokenGetAll(buffer);\n};\n\n/**\n * Extract tokens from the specified buffer.\n * > Note that the output tokens are *STRICLY* similar to PHP function `token_get_all`\n * @param {String} buffer\n * @return {String[]} - Each item can be a string or an array with following informations [token_name, text, line_number]\n */\nengine.prototype.tokenGetAll = function (buffer) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = true;\n  buffer = getStringBuffer(buffer);\n  const EOF = this.lexer.EOF;\n  const names = this.tokens.values;\n  this.lexer.setInput(buffer);\n  let token = this.lexer.lex() || EOF;\n  const result = [];\n  while (token != EOF) {\n    let entry = this.lexer.yytext;\n    if (names.hasOwnProperty(token)) {\n      entry = [names[token], entry, this.lexer.yylloc.first_line];\n    }\n    result.push(entry);\n    token = this.lexer.lex() || EOF;\n  }\n  return result;\n};\n\n// exports the function\nmodule.exports = engine;\n\n// makes libraries public\nmodule.exports.tokens = tokens;\nmodule.exports.lexer = lexer;\nmodule.exports.AST = AST;\nmodule.exports.parser = parser;\nmodule.exports.combine = combine;\n\n// allow the default export in index.d.ts\nmodule.exports.default = engine;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * This is the php lexer. It will tokenize the string for helping the\n * parser to build the AST from its grammar.\n *\n * @class\n * @property {Integer} EOF\n * @property {Boolean} all_tokens defines if all tokens must be retrieved (used by token_get_all only)\n * @property {Boolean} comment_tokens extracts comments tokens\n * @property {Boolean} mode_eval enables the evald mode (ignore opening tags)\n * @property {Boolean} asp_tags disables by default asp tags mode\n * @property {Boolean} short_tags enables by default short tags mode\n * @property {Object} keywords List of php keyword\n * @property {Object} castKeywords List of php keywords for type casting\n */\nconst lexer = function (engine) {\n  this.engine = engine;\n  this.tok = this.engine.tokens.names;\n  this.EOF = 1;\n  this.debug = false;\n  this.all_tokens = true;\n  this.comment_tokens = false;\n  this.mode_eval = false;\n  this.asp_tags = false;\n  this.short_tags = false;\n  this.version = 704;\n  this.yyprevcol = 0;\n  this.keywords = {\n    __class__: this.tok.T_CLASS_C,\n    __trait__: this.tok.T_TRAIT_C,\n    __function__: this.tok.T_FUNC_C,\n    __method__: this.tok.T_METHOD_C,\n    __line__: this.tok.T_LINE,\n    __file__: this.tok.T_FILE,\n    __dir__: this.tok.T_DIR,\n    __namespace__: this.tok.T_NS_C,\n    exit: this.tok.T_EXIT,\n    die: this.tok.T_EXIT,\n    function: this.tok.T_FUNCTION,\n    const: this.tok.T_CONST,\n    return: this.tok.T_RETURN,\n    try: this.tok.T_TRY,\n    catch: this.tok.T_CATCH,\n    finally: this.tok.T_FINALLY,\n    throw: this.tok.T_THROW,\n    if: this.tok.T_IF,\n    elseif: this.tok.T_ELSEIF,\n    endif: this.tok.T_ENDIF,\n    else: this.tok.T_ELSE,\n    while: this.tok.T_WHILE,\n    endwhile: this.tok.T_ENDWHILE,\n    do: this.tok.T_DO,\n    for: this.tok.T_FOR,\n    endfor: this.tok.T_ENDFOR,\n    foreach: this.tok.T_FOREACH,\n    endforeach: this.tok.T_ENDFOREACH,\n    declare: this.tok.T_DECLARE,\n    enddeclare: this.tok.T_ENDDECLARE,\n    instanceof: this.tok.T_INSTANCEOF,\n    as: this.tok.T_AS,\n    switch: this.tok.T_SWITCH,\n    endswitch: this.tok.T_ENDSWITCH,\n    case: this.tok.T_CASE,\n    default: this.tok.T_DEFAULT,\n    break: this.tok.T_BREAK,\n    continue: this.tok.T_CONTINUE,\n    goto: this.tok.T_GOTO,\n    echo: this.tok.T_ECHO,\n    print: this.tok.T_PRINT,\n    class: this.tok.T_CLASS,\n    interface: this.tok.T_INTERFACE,\n    trait: this.tok.T_TRAIT,\n    extends: this.tok.T_EXTENDS,\n    implements: this.tok.T_IMPLEMENTS,\n    new: this.tok.T_NEW,\n    clone: this.tok.T_CLONE,\n    var: this.tok.T_VAR,\n    eval: this.tok.T_EVAL,\n    include: this.tok.T_INCLUDE,\n    include_once: this.tok.T_INCLUDE_ONCE,\n    require: this.tok.T_REQUIRE,\n    require_once: this.tok.T_REQUIRE_ONCE,\n    namespace: this.tok.T_NAMESPACE,\n    use: this.tok.T_USE,\n    insteadof: this.tok.T_INSTEADOF,\n    global: this.tok.T_GLOBAL,\n    isset: this.tok.T_ISSET,\n    empty: this.tok.T_EMPTY,\n    __halt_compiler: this.tok.T_HALT_COMPILER,\n    static: this.tok.T_STATIC,\n    abstract: this.tok.T_ABSTRACT,\n    final: this.tok.T_FINAL,\n    private: this.tok.T_PRIVATE,\n    protected: this.tok.T_PROTECTED,\n    public: this.tok.T_PUBLIC,\n    unset: this.tok.T_UNSET,\n    list: this.tok.T_LIST,\n    array: this.tok.T_ARRAY,\n    callable: this.tok.T_CALLABLE,\n    or: this.tok.T_LOGICAL_OR,\n    and: this.tok.T_LOGICAL_AND,\n    xor: this.tok.T_LOGICAL_XOR,\n  };\n  this.castKeywords = {\n    int: this.tok.T_INT_CAST,\n    integer: this.tok.T_INT_CAST,\n    real: this.tok.T_DOUBLE_CAST,\n    double: this.tok.T_DOUBLE_CAST,\n    float: this.tok.T_DOUBLE_CAST,\n    string: this.tok.T_STRING_CAST,\n    binary: this.tok.T_STRING_CAST,\n    array: this.tok.T_ARRAY_CAST,\n    object: this.tok.T_OBJECT_CAST,\n    bool: this.tok.T_BOOL_CAST,\n    boolean: this.tok.T_BOOL_CAST,\n    unset: this.tok.T_UNSET_CAST,\n  };\n};\n\n/**\n * Initialize the lexer with the specified input\n */\nlexer.prototype.setInput = function (input) {\n  this._input = input;\n  this.size = input.length;\n  this.yylineno = 1;\n  this.offset = 0;\n  this.yyprevcol = 0;\n  this.yytext = \"\";\n  this.yylloc = {\n    first_offset: 0,\n    first_line: 1,\n    first_column: 0,\n    prev_offset: 0,\n    prev_line: 1,\n    prev_column: 0,\n    last_line: 1,\n    last_column: 0,\n  };\n  this.tokens = [];\n  if (this.version > 703) {\n    this.keywords.fn = this.tok.T_FN;\n  } else {\n    delete this.keywords.fn;\n  }\n  this.done = this.offset >= this.size;\n  if (!this.all_tokens && this.mode_eval) {\n    this.conditionStack = [\"INITIAL\"];\n    this.begin(\"ST_IN_SCRIPTING\");\n  } else {\n    this.conditionStack = [];\n    this.begin(\"INITIAL\");\n  }\n  // https://github.com/php/php-src/blob/999e32b65a8a4bb59e27e538fa68ffae4b99d863/Zend/zend_language_scanner.h#L59\n  // Used for heredoc and nowdoc\n  this.heredoc_label = {\n    label: \"\",\n    length: 0,\n    indentation: 0,\n    indentation_uses_spaces: false,\n    finished: false,\n    /**\n     * this used for parser to detemine the if current node segment is first encaps node.\n     * if ture, the indentation will remove from the begining. and if false, the prev node\n     * might be a variable '}' ,and the leading spaces should not be removed util meet the\n     * first \\n\n     */\n    first_encaps_node: false,\n    // for backward compatible\n    toString: function () {\n      this.label;\n    },\n  };\n  return this;\n};\n\n/**\n * consumes and returns one char from the input\n */\nlexer.prototype.input = function () {\n  const ch = this._input[this.offset];\n  if (!ch) return \"\";\n  this.yytext += ch;\n  this.offset++;\n  if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n    this.yytext += \"\\n\";\n    this.offset++;\n  }\n  if (ch === \"\\n\" || ch === \"\\r\") {\n    this.yylloc.last_line = ++this.yylineno;\n    this.yyprevcol = this.yylloc.last_column;\n    this.yylloc.last_column = 0;\n  } else {\n    this.yylloc.last_column++;\n  }\n  return ch;\n};\n\n/**\n * revert eating specified size\n */\nlexer.prototype.unput = function (size) {\n  if (size === 1) {\n    // 1 char unput (most cases)\n    this.offset--;\n    if (\n      this._input[this.offset] === \"\\n\" &&\n      this._input[this.offset - 1] === \"\\r\"\n    ) {\n      this.offset--;\n      size++;\n    }\n    if (\n      this._input[this.offset] === \"\\r\" ||\n      this._input[this.offset] === \"\\n\"\n    ) {\n      this.yylloc.last_line--;\n      this.yylineno--;\n      this.yylloc.last_column = this.yyprevcol;\n    } else {\n      this.yylloc.last_column--;\n    }\n    this.yytext = this.yytext.substring(0, this.yytext.length - size);\n  } else if (size > 0) {\n    this.offset -= size;\n    if (size < this.yytext.length) {\n      this.yytext = this.yytext.substring(0, this.yytext.length - size);\n      // re-calculate position\n      this.yylloc.last_line = this.yylloc.first_line;\n      this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;\n      for (let i = 0; i < this.yytext.length; i++) {\n        let c = this.yytext[i];\n        if (c === \"\\r\") {\n          c = this.yytext[++i];\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n          if (c !== \"\\n\") {\n            if (c === \"\\r\") {\n              this.yylloc.last_line++;\n            } else {\n              this.yylloc.last_column++;\n            }\n          }\n        } else if (c === \"\\n\") {\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n        } else {\n          this.yylloc.last_column++;\n        }\n      }\n      this.yylineno = this.yylloc.last_line;\n    } else {\n      // reset full text\n      this.yytext = \"\";\n      this.yylloc.last_line = this.yylineno = this.yylloc.first_line;\n      this.yylloc.last_column = this.yylloc.first_column;\n    }\n  }\n\n  return this;\n};\n\n// check if the text matches\nlexer.prototype.tryMatch = function (text) {\n  return text === this.ahead(text.length);\n};\n\n// check if the text matches\nlexer.prototype.tryMatchCaseless = function (text) {\n  return text === this.ahead(text.length).toLowerCase();\n};\n\n// look ahead\nlexer.prototype.ahead = function (size) {\n  let text = this._input.substring(this.offset, this.offset + size);\n  if (\n    text[text.length - 1] === \"\\r\" &&\n    this._input[this.offset + size + 1] === \"\\n\"\n  ) {\n    text += \"\\n\";\n  }\n  return text;\n};\n\n// consume the specified size\nlexer.prototype.consume = function (size) {\n  for (let i = 0; i < size; i++) {\n    const ch = this._input[this.offset];\n    if (!ch) break;\n    this.yytext += ch;\n    this.offset++;\n    if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n      this.yytext += \"\\n\";\n      this.offset++;\n      i++;\n    }\n    if (ch === \"\\n\" || ch === \"\\r\") {\n      this.yylloc.last_line = ++this.yylineno;\n      this.yyprevcol = this.yylloc.last_column;\n      this.yylloc.last_column = 0;\n    } else {\n      this.yylloc.last_column++;\n    }\n  }\n  return this;\n};\n\n/**\n * Gets the current state\n */\nlexer.prototype.getState = function () {\n  return {\n    yytext: this.yytext,\n    offset: this.offset,\n    yylineno: this.yylineno,\n    yyprevcol: this.yyprevcol,\n    yylloc: {\n      first_offset: this.yylloc.first_offset,\n      first_line: this.yylloc.first_line,\n      first_column: this.yylloc.first_column,\n      last_line: this.yylloc.last_line,\n      last_column: this.yylloc.last_column,\n    },\n    heredoc_label: this.heredoc_label,\n  };\n};\n\n/**\n * Sets the current lexer state\n */\nlexer.prototype.setState = function (state) {\n  this.yytext = state.yytext;\n  this.offset = state.offset;\n  this.yylineno = state.yylineno;\n  this.yyprevcol = state.yyprevcol;\n  this.yylloc = state.yylloc;\n  if (state.heredoc_label) {\n    this.heredoc_label = state.heredoc_label;\n  }\n  return this;\n};\n\n// prepend next token\nlexer.prototype.appendToken = function (value, ahead) {\n  this.tokens.push([value, ahead]);\n  return this;\n};\n\n// return next match that has a token\nlexer.prototype.lex = function () {\n  this.yylloc.prev_offset = this.offset;\n  this.yylloc.prev_line = this.yylloc.last_line;\n  this.yylloc.prev_column = this.yylloc.last_column;\n  let token = this.next() || this.lex();\n  if (!this.all_tokens) {\n    while (\n      token === this.tok.T_WHITESPACE || // ignore white space\n      (!this.comment_tokens &&\n        (token === this.tok.T_COMMENT || // ignore single lines comments\n          token === this.tok.T_DOC_COMMENT)) || // ignore doc comments\n      // ignore open tags\n      token === this.tok.T_OPEN_TAG\n    ) {\n      token = this.next() || this.lex();\n    }\n    if (token == this.tok.T_OPEN_TAG_WITH_ECHO) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1683\n      // open tag with echo statement\n      return this.tok.T_ECHO;\n    } else if (token === this.tok.T_CLOSE_TAG) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n      return \";\"; /* implicit ; */\n    }\n  }\n  if (!this.yylloc.prev_offset) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n  }\n  /*else if (this.yylloc.prev_offset === this.offset && this.offset !== this.size) {\n    throw new Error('Infinite loop @ ' + this.offset + ' / ' + this.size);\n  }*/\n  return token;\n};\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nlexer.prototype.begin = function (condition) {\n  this.conditionStack.push(condition);\n  this.curCondition = condition;\n  this.stateCb = this[\"match\" + condition];\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + condition + '\"');\n  }\n  return this;\n};\n\n// pop the previously active lexer condition state off the condition stack\nlexer.prototype.popState = function () {\n  const n = this.conditionStack.length - 1;\n  const condition = n > 0 ? this.conditionStack.pop() : this.conditionStack[0];\n  this.curCondition = this.conditionStack[this.conditionStack.length - 1];\n  this.stateCb = this[\"match\" + this.curCondition];\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + this.curCondition + '\"');\n  }\n  return condition;\n};\n\n// return next match in input\nlexer.prototype.next = function () {\n  let token;\n  if (!this._input) {\n    this.done = true;\n  }\n  this.yylloc.first_offset = this.offset;\n  this.yylloc.first_line = this.yylloc.last_line;\n  this.yylloc.first_column = this.yylloc.last_column;\n  this.yytext = \"\";\n  if (this.done) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n    return this.EOF;\n  }\n  if (this.tokens.length > 0) {\n    token = this.tokens.shift();\n    if (typeof token[1] === \"object\") {\n      this.setState(token[1]);\n    } else {\n      this.consume(token[1]);\n    }\n    token = token[0];\n  } else {\n    token = this.stateCb.apply(this, []);\n  }\n  if (this.offset >= this.size && this.tokens.length === 0) {\n    this.done = true;\n  }\n  if (this.debug) {\n    let tName = token;\n    if (typeof tName === \"number\") {\n      tName = this.engine.tokens.values[tName];\n    } else {\n      tName = '\"' + tName + '\"';\n    }\n    const e = new Error(\n      tName +\n        \"\\tfrom \" +\n        this.yylloc.first_line +\n        \",\" +\n        this.yylloc.first_column +\n        \"\\t - to \" +\n        this.yylloc.last_line +\n        \",\" +\n        this.yylloc.last_column +\n        '\\t\"' +\n        this.yytext +\n        '\"'\n    );\n    // eslint-disable-next-line no-console\n    console.error(e.stack);\n  }\n  return token;\n};\n\n// extends the lexer with states\n[\n  require(\"./lexer/comments.js\"),\n  require(\"./lexer/initial.js\"),\n  require(\"./lexer/numbers.js\"),\n  require(\"./lexer/property.js\"),\n  require(\"./lexer/scripting.js\"),\n  require(\"./lexer/strings.js\"),\n  require(\"./lexer/tokens.js\"),\n  require(\"./lexer/utils.js\"),\n].forEach(function (ext) {\n  for (const k in ext) {\n    lexer.prototype[k] = ext[k];\n  }\n});\n\nmodule.exports = lexer;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a single line comment\n   */\n  T_COMMENT: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (ch === \"\\n\" || ch === \"\\r\") {\n        return this.tok.T_COMMENT;\n      } else if (\n        ch === \"?\" &&\n        !this.aspTagMode &&\n        this._input[this.offset] === \">\"\n      ) {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      } else if (\n        ch === \"%\" &&\n        this.aspTagMode &&\n        this._input[this.offset] === \">\"\n      ) {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      }\n    }\n    return this.tok.T_COMMENT;\n  },\n  /**\n   * Behaviour : https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1927\n   */\n  T_DOC_COMMENT: function () {\n    let ch = this.input();\n    let token = this.tok.T_COMMENT;\n    if (ch === \"*\") {\n      // started with '/*' , check is next is '*'\n      ch = this.input();\n      if (this.is_WHITESPACE()) {\n        // check if next is WHITESPACE\n        token = this.tok.T_DOC_COMMENT;\n      }\n      if (ch === \"/\") {\n        return token;\n      } else {\n        this.unput(1); // reset\n      }\n    }\n    while (this.offset < this.size) {\n      ch = this.input();\n      if (ch === \"*\" && this._input[this.offset] === \"/\") {\n        this.input();\n        break;\n      }\n    }\n    return token;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  nextINITIAL: function () {\n    if (\n      this.conditionStack.length > 1 &&\n      this.conditionStack[this.conditionStack.length - 1] === \"INITIAL\"\n    ) {\n      // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n      this.popState();\n    } else {\n      this.begin(\"ST_IN_SCRIPTING\");\n    }\n    return this;\n  },\n  matchINITIAL: function () {\n    while (this.offset < this.size) {\n      let ch = this.input();\n      if (ch == \"<\") {\n        ch = this.ahead(1);\n        if (ch == \"?\") {\n          if (this.tryMatch(\"?=\")) {\n            this.unput(1)\n              .appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3)\n              .nextINITIAL();\n            break;\n          } else if (this.tryMatchCaseless(\"?php\")) {\n            ch = this._input[this.offset + 4];\n            if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();\n              break;\n            }\n          }\n          if (this.short_tags) {\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        } else if (this.asp_tags && ch == \"%\") {\n          if (this.tryMatch(\"%=\")) {\n            this.aspTagMode = true;\n            this.unput(1)\n              .appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3)\n              .nextINITIAL();\n            break;\n          } else {\n            this.aspTagMode = true;\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        }\n      }\n    }\n    if (this.yytext.length > 0) {\n      return this.tok.T_INLINE_HTML;\n    } else {\n      return false;\n    }\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/* istanbul ignore else  */\nlet MAX_LENGTH_OF_LONG = 10;\nlet long_min_digits = \"2147483648\";\nif (process.arch == \"x64\") {\n  MAX_LENGTH_OF_LONG = 19;\n  long_min_digits = \"9223372036854775808\";\n}\n\nmodule.exports = {\n  consume_NUM: function () {\n    let ch = this.yytext[0];\n    let hasPoint = ch === \".\";\n    if (ch === \"0\") {\n      ch = this.input();\n      // check if hexa\n      if (ch === \"x\" || ch === \"X\") {\n        ch = this.input();\n        if (ch !== \"_\" && this.is_HEX()) {\n          return this.consume_HNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        }\n        // check binary notation\n      } else if (ch === \"b\" || ch === \"B\") {\n        ch = this.input();\n        if ((ch !== \"_\" && ch === \"0\") || ch === \"1\") {\n          return this.consume_BNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        }\n        // @fixme check octal notation ? not usefull\n      } else if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n      }\n    }\n\n    while (this.offset < this.size) {\n      const prev = ch;\n      ch = this.input();\n\n      if (ch === \"_\") {\n        if (prev === \"_\") {\n          // restriction : next to underscore / 1__1;\n          this.unput(2); // keep 1\n          break;\n        }\n        if (prev === \".\") {\n          // next to decimal point  \"1._0\"\n          this.unput(1); // keep 1.\n          break;\n        }\n        if (prev === \"e\" || prev === \"E\") {\n          // next to e \"1e_10\"\n          this.unput(2); // keep 1\n          break;\n        }\n      } else if (ch === \".\") {\n        if (hasPoint) {\n          // no multiple points \"1.0.5\"\n          this.unput(1); // keep 1.0\n          break;\n        }\n        if (prev === \"_\") {\n          // next to decimal point  \"1_.0\"\n          this.unput(2); // keep 1\n          break;\n        }\n        hasPoint = true;\n        continue;\n      } else if (ch === \"e\" || ch === \"E\") {\n        if (prev === \"_\") {\n          // next to e \"1_e10\"\n          this.unput(1);\n          break;\n        }\n        let undo = 2;\n        ch = this.input();\n        if (ch === \"+\" || ch === \"-\") {\n          // 1e-5\n          undo = 3;\n          ch = this.input();\n        }\n        if (this.is_NUM_START()) {\n          this.consume_LNUM();\n          return this.tok.T_DNUMBER;\n        }\n        this.unput(ch ? undo : undo - 1); // keep only 1\n        break;\n      }\n\n      if (!this.is_NUM()) {\n        // example : 10.0a\n        if (ch) this.unput(1); // keep 10.0\n        break;\n      }\n    }\n\n    if (hasPoint) {\n      return this.tok.T_DNUMBER;\n    } else if (this.yytext.length < MAX_LENGTH_OF_LONG - 1) {\n      return this.tok.T_LNUMBER;\n    } else {\n      if (\n        this.yytext.length < MAX_LENGTH_OF_LONG ||\n        (this.yytext.length == MAX_LENGTH_OF_LONG &&\n          this.yytext < long_min_digits)\n      ) {\n        return this.tok.T_LNUMBER;\n      }\n      return this.tok.T_DNUMBER;\n    }\n  },\n  // read hexa\n  consume_HNUM: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (!this.is_HEX()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n    return this.tok.T_LNUMBER;\n  },\n  // read a generic number\n  consume_LNUM: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n    return this.tok.T_LNUMBER;\n  },\n  // read binary\n  consume_BNUM: function () {\n    let ch;\n    while (this.offset < this.size) {\n      ch = this.input();\n      if (ch !== \"0\" && ch !== \"1\" && ch !== \"_\") {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n    return this.tok.T_LNUMBER;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  matchST_LOOKING_FOR_PROPERTY: function () {\n    let ch = this.input();\n    if (ch === \"-\") {\n      ch = this.input();\n      if (ch === \">\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1296\n        return this.tok.T_OBJECT_OPERATOR;\n      }\n      if (ch) this.unput(1);\n    } else if (this.is_WHITESPACE()) {\n      return this.tok.T_WHITESPACE;\n    } else if (this.is_LABEL_START()) {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1300\n      this.consume_LABEL();\n      this.popState();\n      return this.tok.T_STRING;\n    }\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1306\n    this.popState();\n    if (ch) this.unput(1);\n    return false;\n  },\n  matchST_LOOKING_FOR_VARNAME: function () {\n    let ch = this.input();\n\n    // SHIFT STATE\n    this.popState();\n    this.begin(\"ST_IN_SCRIPTING\");\n\n    if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      ch = this.input();\n      if (ch === \"[\" || ch === \"}\") {\n        this.unput(1);\n        return this.tok.T_STRING_VARNAME;\n      } else {\n        // any char (that's started with a label sequence)\n        this.unput(this.yytext.length);\n      }\n    } else {\n      // any char (thats not a label start sequence)\n      if (ch) this.unput(1);\n    }\n    // stops looking for a varname and starts the scripting mode\n    return false;\n  },\n  matchST_VAR_OFFSET: function () {\n    const ch = this.input();\n    if (this.is_NUM_START()) {\n      this.consume_NUM();\n      return this.tok.T_NUM_STRING;\n    } else if (ch === \"]\") {\n      this.popState();\n      return \"]\";\n    } else if (ch === \"$\") {\n      this.input();\n      if (this.is_LABEL_START()) {\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        throw new Error(\"Unexpected terminal\");\n      }\n    } else if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      return this.tok.T_STRING;\n    } else if (\n      this.is_WHITESPACE() ||\n      ch === \"\\\\\" ||\n      ch === \"'\" ||\n      ch === \"#\"\n    ) {\n      return this.tok.T_ENCAPSED_AND_WHITESPACE;\n    } else if (\n      ch === \"[\" ||\n      ch === \"{\" ||\n      ch === \"}\" ||\n      ch === '\"' ||\n      ch === \"`\" ||\n      this.is_TOKEN()\n    ) {\n      return ch;\n    } else {\n      throw new Error(\"Unexpected terminal\");\n    }\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  matchST_IN_SCRIPTING: function () {\n    let ch = this.input();\n    switch (ch) {\n      case \" \":\n      case \"\\t\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\r\\n\":\n        return this.T_WHITESPACE();\n      case \"#\":\n        return this.T_COMMENT();\n      case \"/\":\n        if (this._input[this.offset] === \"/\") {\n          return this.T_COMMENT();\n        } else if (this._input[this.offset] === \"*\") {\n          this.input();\n          return this.T_DOC_COMMENT();\n        }\n        return this.consume_TOKEN();\n      case \"'\":\n        return this.T_CONSTANT_ENCAPSED_STRING();\n      case '\"':\n        return this.ST_DOUBLE_QUOTES();\n      case \"`\":\n        this.begin(\"ST_BACKQUOTE\");\n        return \"`\";\n      case \"?\":\n        if (!this.aspTagMode && this.tryMatch(\">\")) {\n          this.input();\n          const nextCH = this._input[this.offset];\n          if (nextCH === \"\\n\" || nextCH === \"\\r\") this.input();\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n          return this.tok.T_CLOSE_TAG;\n        }\n        return this.consume_TOKEN();\n      case \"%\":\n        if (this.aspTagMode && this._input[this.offset] === \">\") {\n          this.input(); // consume the '>'\n          ch = this._input[this.offset]; // read next\n          if (ch === \"\\n\" || ch === \"\\r\") {\n            this.input(); // consume the newline\n          }\n          this.aspTagMode = false;\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n          return this.tok.T_CLOSE_TAG;\n        }\n        return this.consume_TOKEN();\n      case \"{\":\n        this.begin(\"ST_IN_SCRIPTING\");\n        return \"{\";\n      case \"}\":\n        if (this.conditionStack.length > 2) {\n          // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n          this.popState();\n        }\n        return \"}\";\n      default:\n        if (ch === \".\") {\n          ch = this.input();\n          if (this.is_NUM_START()) {\n            return this.consume_NUM();\n          } else {\n            if (ch) this.unput(1);\n          }\n        }\n        if (this.is_NUM_START()) {\n          return this.consume_NUM();\n        } else if (this.is_LABEL_START()) {\n          return this.consume_LABEL().T_STRING();\n        } else if (this.is_TOKEN()) {\n          return this.consume_TOKEN();\n        }\n    }\n    throw new Error(\n      'Bad terminal sequence \"' +\n        ch +\n        '\" at line ' +\n        this.yylineno +\n        \" (offset \" +\n        this.offset +\n        \")\"\n    );\n  },\n\n  T_WHITESPACE: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n        continue;\n      }\n      if (ch) this.unput(1);\n      break;\n    }\n    return this.tok.T_WHITESPACE;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst newline = [\"\\n\", \"\\r\"];\nconst valid_after_heredoc = [\"\\n\", \"\\r\", \";\"];\nconst valid_after_heredoc_73 = valid_after_heredoc.concat([\n  \"\\t\",\n  \" \",\n  \",\",\n  \"]\",\n  \")\",\n  \"/\",\n  \"=\",\n  \"!\",\n]);\n\nmodule.exports = {\n  T_CONSTANT_ENCAPSED_STRING: function () {\n    let ch;\n    while (this.offset < this.size) {\n      ch = this.input();\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == \"'\") {\n        break;\n      }\n    }\n    return this.tok.T_CONSTANT_ENCAPSED_STRING;\n  },\n  // check if matching a HEREDOC state\n  is_HEREDOC: function () {\n    const revert = this.offset;\n    if (\n      this._input[this.offset - 1] === \"<\" &&\n      this._input[this.offset] === \"<\" &&\n      this._input[this.offset + 1] === \"<\"\n    ) {\n      this.offset += 3;\n\n      // optional tabs / spaces\n      if (this.is_TABSPACE()) {\n        while (this.offset < this.size) {\n          this.offset++;\n          if (!this.is_TABSPACE()) {\n            break;\n          }\n        }\n      }\n\n      // optional quotes\n      let tChar = this._input[this.offset - 1];\n      if (tChar === \"'\" || tChar === '\"') {\n        this.offset++;\n      } else {\n        tChar = null;\n      }\n\n      // required label\n      if (this.is_LABEL_START()) {\n        let yyoffset = this.offset - 1;\n        while (this.offset < this.size) {\n          this.offset++;\n          if (!this.is_LABEL()) {\n            break;\n          }\n        }\n        const yylabel = this._input.substring(yyoffset, this.offset - 1);\n        if (!tChar || tChar === this._input[this.offset - 1]) {\n          // required ending quote\n          if (tChar) this.offset++;\n          // require newline\n          if (newline.includes(this._input[this.offset - 1])) {\n            // go go go\n            this.heredoc_label.label = yylabel;\n            this.heredoc_label.length = yylabel.length;\n            this.heredoc_label.finished = false;\n            yyoffset = this.offset - revert;\n            this.offset = revert;\n            this.consume(yyoffset);\n            if (tChar === \"'\") {\n              this.begin(\"ST_NOWDOC\");\n            } else {\n              this.begin(\"ST_HEREDOC\");\n            }\n            // prematch to get the indentation information from end of doc\n            this.prematch_ENDOFDOC();\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n      }\n    }\n    this.offset = revert;\n    return false;\n  },\n  ST_DOUBLE_QUOTES: function () {\n    let ch;\n    while (this.offset < this.size) {\n      ch = this.input();\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == '\"') {\n        break;\n      } else if (ch == \"$\") {\n        ch = this.input();\n        if (ch == \"{\" || this.is_LABEL_START()) {\n          this.unput(2);\n          break;\n        }\n        if (ch) this.unput(1);\n      } else if (ch == \"{\") {\n        ch = this.input();\n        if (ch == \"$\") {\n          this.unput(2);\n          break;\n        }\n        if (ch) this.unput(1);\n      }\n    }\n    if (ch == '\"') {\n      return this.tok.T_CONSTANT_ENCAPSED_STRING;\n    } else {\n      let prefix = 1;\n      if (this.yytext[0] === \"b\" || this.yytext[0] === \"B\") {\n        prefix = 2;\n      }\n      if (this.yytext.length > 2) {\n        this.appendToken(\n          this.tok.T_ENCAPSED_AND_WHITESPACE,\n          this.yytext.length - prefix\n        );\n      }\n      this.unput(this.yytext.length - prefix);\n      this.begin(\"ST_DOUBLE_QUOTES\");\n      return this.yytext;\n    }\n  },\n\n  // check if its a DOC end sequence\n  isDOC_MATCH: function (offset, consumeLeadingSpaces) {\n    // @fixme : check if out of text limits\n\n    // consumeLeadingSpaces is false happen DOC prematch END HEREDOC stage.\n\n    // Ensure current state is really after a new line break, not after a such as ${variables}\n    const prev_ch = this._input[offset - 2];\n    if (!newline.includes(prev_ch)) {\n      return false;\n    }\n\n    // skip leading spaces or tabs\n    let indentation_uses_spaces = false;\n    let indentation_uses_tabs = false;\n    // reset heredoc_label structure\n    let indentation = 0;\n    let leading_ch = this._input[offset - 1];\n\n    if (this.version >= 703) {\n      while (leading_ch === \"\\t\" || leading_ch === \" \") {\n        if (leading_ch === \" \") {\n          indentation_uses_spaces = true;\n        } else if (leading_ch === \"\\t\") {\n          indentation_uses_tabs = true;\n        }\n\n        leading_ch = this._input[offset + indentation];\n        indentation++;\n      }\n\n      // Move offset to skip leading whitespace\n      offset = offset + indentation;\n\n      // return out if there was only whitespace on this line\n      if (newline.includes(this._input[offset - 1])) {\n        return false;\n      }\n    }\n\n    if (\n      this._input.substring(\n        offset - 1,\n        offset - 1 + this.heredoc_label.length\n      ) === this.heredoc_label.label\n    ) {\n      const ch = this._input[offset - 1 + this.heredoc_label.length];\n      if (\n        (this.version >= 703\n          ? valid_after_heredoc_73\n          : valid_after_heredoc\n        ).includes(ch)\n      ) {\n        if (consumeLeadingSpaces) {\n          this.consume(indentation);\n          // https://wiki.php.net/rfc/flexible_heredoc_nowdoc_syntaxes\n          if (indentation_uses_spaces && indentation_uses_tabs) {\n            throw new Error(\n              \"Parse error:  mixing spaces and tabs in ending marker at line \" +\n                this.yylineno +\n                \" (offset \" +\n                this.offset +\n                \")\"\n            );\n          }\n        } else {\n          // Called in prematch_ENDOFDOC\n          this.heredoc_label.indentation = indentation;\n          this.heredoc_label.indentation_uses_spaces = indentation_uses_spaces;\n          this.heredoc_label.first_encaps_node = true;\n        }\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Prematch the end of HEREDOC/NOWDOC end tag to preset the\n   * context of this.heredoc_label\n   */\n  prematch_ENDOFDOC: function () {\n    // reset heredoc\n    this.heredoc_label.indentation_uses_spaces = false;\n    this.heredoc_label.indentation = 0;\n    this.heredoc_label.first_encaps_node = true;\n    let offset = this.offset + 1;\n\n    while (offset < this._input.length) {\n      // if match heredoc_label structrue will be set\n      if (this.isDOC_MATCH(offset, false)) {\n        return;\n      }\n\n      if (!newline.includes(this._input[offset - 1])) {\n        // skip one line\n        while (\n          !newline.includes(this._input[offset++]) &&\n          offset < this._input.length\n        ) {\n          // skip\n        }\n      }\n\n      offset++;\n    }\n  },\n\n  matchST_NOWDOC: function () {\n    /** edge case : empty now doc **/\n    if (this.isDOC_MATCH(this.offset, true)) {\n      // @fixme : never reached (may be caused by quotes)\n      this.consume(this.heredoc_label.length);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n    let ch = this._input[this.offset - 1];\n    while (this.offset < this.size) {\n      if (newline.includes(ch)) {\n        ch = this.input();\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else {\n        ch = this.input();\n      }\n    }\n    // too bad ! reached end of document (will get a parse error)\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n\n  matchST_HEREDOC: function () {\n    /** edge case : empty here doc **/\n    let ch = this.input();\n    if (this.isDOC_MATCH(this.offset, true)) {\n      this.consume(this.heredoc_label.length - 1);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        ch = this.input(); // ignore next\n        if (!newline.includes(ch)) {\n          ch = this.input();\n        }\n      }\n\n      if (newline.includes(ch)) {\n        ch = this.input();\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else if (ch === \"$\") {\n        ch = this.input();\n        if (ch === \"{\") {\n          // start of ${\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          const yyoffset = this.offset;\n          const next = this.consume_VARIABLE();\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n          //console.log(this.yytext);\n        }\n      } else if (ch === \"{\") {\n        ch = this.input();\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n      } else {\n        ch = this.input();\n      }\n    }\n\n    // too bad ! reached end of document (will get a parse error)\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n\n  consume_VARIABLE: function () {\n    this.consume_LABEL();\n    const ch = this.input();\n    if (ch == \"[\") {\n      this.unput(1);\n      this.begin(\"ST_VAR_OFFSET\");\n      return this.tok.T_VARIABLE;\n    } else if (ch === \"-\") {\n      if (this.input() === \">\") {\n        this.input();\n        if (this.is_LABEL_START()) {\n          this.begin(\"ST_LOOKING_FOR_PROPERTY\");\n        }\n        this.unput(3);\n        return this.tok.T_VARIABLE;\n      } else {\n        this.unput(2);\n      }\n    } else {\n      if (ch) this.unput(1);\n    }\n    return this.tok.T_VARIABLE;\n  },\n  // HANDLES BACKQUOTES\n  matchST_BACKQUOTE: function () {\n    let ch = this.input();\n    if (ch === \"$\") {\n      ch = this.input();\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        const tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === \"`\") {\n      this.popState();\n      return \"`\";\n    }\n\n    // any char\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === \"`\") {\n        this.unput(1);\n        this.popState();\n        this.appendToken(\"`\", 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          const yyoffset = this.offset;\n          const next = this.consume_VARIABLE();\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n        continue;\n      } else if (ch === \"{\") {\n        ch = this.input();\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n        continue;\n      }\n      ch = this.input();\n    }\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n\n  matchST_DOUBLE_QUOTES: function () {\n    let ch = this.input();\n    if (ch === \"$\") {\n      ch = this.input();\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        const tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === '\"') {\n      this.popState();\n      return '\"';\n    }\n\n    // any char\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === '\"') {\n        this.unput(1);\n        this.popState();\n        this.appendToken('\"', 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          const yyoffset = this.offset;\n          const next = this.consume_VARIABLE();\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n        if (ch) this.unput(1);\n      } else if (ch === \"{\") {\n        ch = this.input();\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            // @fixme : yytext = '\"{$' (this.yytext.length > 3)\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n        if (ch) this.unput(1);\n      }\n      ch = this.input();\n    }\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  T_STRING: function () {\n    const token = this.yytext.toLowerCase();\n    let id = this.keywords[token];\n    if (typeof id !== \"number\") {\n      if (token === \"yield\") {\n        if (this.version >= 700 && this.tryMatch(\" from\")) {\n          this.consume(5);\n          id = this.tok.T_YIELD_FROM;\n        } else {\n          id = this.tok.T_YIELD;\n        }\n      } else {\n        id = this.tok.T_STRING;\n        if (token === \"b\" || token === \"B\") {\n          const ch = this.input(1);\n          if (ch === '\"') {\n            return this.ST_DOUBLE_QUOTES();\n          } else if (ch === \"'\") {\n            return this.T_CONSTANT_ENCAPSED_STRING();\n          } else if (ch) {\n            this.unput(1);\n          }\n        }\n      }\n    }\n    return id;\n  },\n  // reads a custom token\n  consume_TOKEN: function () {\n    const ch = this._input[this.offset - 1];\n    const fn = this.tokenTerminals[ch];\n    if (fn) {\n      return fn.apply(this, []);\n    } else {\n      return this.yytext;\n    }\n  },\n  // list of special char tokens\n  tokenTerminals: {\n    $: function () {\n      this.offset++;\n      if (this.is_LABEL_START()) {\n        this.offset--;\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        this.offset--;\n        return \"$\";\n      }\n    },\n    \"-\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \">\") {\n        this.begin(\"ST_LOOKING_FOR_PROPERTY\").input();\n        return this.tok.T_OBJECT_OPERATOR;\n      } else if (nchar === \"-\") {\n        this.input();\n        return this.tok.T_DEC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MINUS_EQUAL;\n      }\n      return \"-\";\n    },\n    \"\\\\\": function () {\n      return this.tok.T_NS_SEPARATOR;\n    },\n    \"/\": function () {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_DIV_EQUAL;\n      }\n      return \"/\";\n    },\n    \":\": function () {\n      if (this._input[this.offset] === \":\") {\n        this.input();\n        return this.tok.T_DOUBLE_COLON;\n      } else {\n        return \":\";\n      }\n    },\n    \"(\": function () {\n      const initial = this.offset;\n      this.input();\n      if (this.is_TABSPACE()) {\n        this.consume_TABSPACE().input();\n      }\n      if (this.is_LABEL_START()) {\n        const yylen = this.yytext.length;\n        this.consume_LABEL();\n        const castToken = this.yytext.substring(yylen - 1).toLowerCase();\n        const castId = this.castKeywords[castToken];\n        if (typeof castId === \"number\") {\n          this.input();\n          if (this.is_TABSPACE()) {\n            this.consume_TABSPACE().input();\n          }\n          if (this._input[this.offset - 1] === \")\") {\n            return castId;\n          }\n        }\n      }\n      // revert the check\n      this.unput(this.offset - initial);\n      return \"(\";\n    },\n    \"=\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \">\") {\n        this.input();\n        return this.tok.T_DOUBLE_ARROW;\n      } else if (nchar === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_EQUAL;\n        }\n      }\n      return \"=\";\n    },\n    \"+\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \"+\") {\n        this.input();\n        return this.tok.T_INC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_PLUS_EQUAL;\n      }\n      return \"+\";\n    },\n    \"!\": function () {\n      if (this._input[this.offset] === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_NOT_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_NOT_EQUAL;\n        }\n      }\n      return \"!\";\n    },\n    \"?\": function () {\n      if (this.version >= 700 && this._input[this.offset] === \"?\") {\n        if (this.version >= 704 && this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_COALESCE_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_COALESCE;\n        }\n      }\n      return \"?\";\n    },\n    \"<\": function () {\n      let nchar = this._input[this.offset];\n      if (nchar === \"<\") {\n        nchar = this._input[this.offset + 1];\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SL_EQUAL;\n        } else if (nchar === \"<\") {\n          if (this.is_HEREDOC()) {\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n        this.input();\n        return this.tok.T_SL;\n      } else if (nchar === \"=\") {\n        this.input();\n        if (this.version >= 700 && this._input[this.offset] === \">\") {\n          this.input();\n          return this.tok.T_SPACESHIP;\n        } else {\n          return this.tok.T_IS_SMALLER_OR_EQUAL;\n        }\n      } else if (nchar === \">\") {\n        this.input();\n        return this.tok.T_IS_NOT_EQUAL;\n      }\n      return \"<\";\n    },\n    \">\": function () {\n      let nchar = this._input[this.offset];\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_IS_GREATER_OR_EQUAL;\n      } else if (nchar === \">\") {\n        nchar = this._input[this.offset + 1];\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SR_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_SR;\n        }\n      }\n      return \">\";\n    },\n    \"*\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MUL_EQUAL;\n      } else if (nchar === \"*\") {\n        this.input();\n        if (this._input[this.offset] === \"=\") {\n          this.input();\n          return this.tok.T_POW_EQUAL;\n        } else {\n          return this.tok.T_POW;\n        }\n      }\n      return \"*\";\n    },\n    \".\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_CONCAT_EQUAL;\n      } else if (nchar === \".\" && this._input[this.offset + 1] === \".\") {\n        this.consume(2);\n        return this.tok.T_ELLIPSIS;\n      }\n      return \".\";\n    },\n    \"%\": function () {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_MOD_EQUAL;\n      }\n      return \"%\";\n    },\n    \"&\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_AND_EQUAL;\n      } else if (nchar === \"&\") {\n        this.input();\n        return this.tok.T_BOOLEAN_AND;\n      }\n      return \"&\";\n    },\n    \"|\": function () {\n      const nchar = this._input[this.offset];\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_OR_EQUAL;\n      } else if (nchar === \"|\") {\n        this.input();\n        return this.tok.T_BOOLEAN_OR;\n      }\n      return \"|\";\n    },\n    \"^\": function () {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_XOR_EQUAL;\n      }\n      return \"^\";\n    },\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst tokens = \";:,.\\\\[]()|^&+-/*=%!~$<>?@\";\n\nmodule.exports = {\n  // check if the char can be a numeric\n  is_NUM: function () {\n    const ch = this._input.charCodeAt(this.offset - 1);\n    return (ch > 47 && ch < 58) || ch === 95;\n  },\n\n  // check if the char can be a numeric\n  is_NUM_START: function () {\n    const ch = this._input.charCodeAt(this.offset - 1);\n    return ch > 47 && ch < 58;\n  },\n\n  // check if current char can be a label\n  is_LABEL: function () {\n    const ch = this._input.charCodeAt(this.offset - 1);\n    return (\n      (ch > 96 && ch < 123) ||\n      (ch > 64 && ch < 91) ||\n      ch === 95 ||\n      (ch > 47 && ch < 58) ||\n      ch > 126\n    );\n  },\n\n  // check if current char can be a label\n  is_LABEL_START: function () {\n    const ch = this._input.charCodeAt(this.offset - 1);\n    // A - Z\n    if (ch > 64 && ch < 91) return true;\n    // a - z\n    if (ch > 96 && ch < 123) return true;\n    // _ (95)\n    if (ch === 95) return true;\n    // utf8 / extended\n    if (ch > 126) return true;\n    // else\n    return false;\n  },\n\n  // reads each char of the label\n  consume_LABEL: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (!this.is_LABEL()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n    return this;\n  },\n\n  // check if current char is a token char\n  is_TOKEN: function () {\n    const ch = this._input[this.offset - 1];\n    return tokens.indexOf(ch) !== -1;\n  },\n  // check if current char is a whitespace\n  is_WHITESPACE: function () {\n    const ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  },\n  // check if current char is a whitespace (without newlines)\n  is_TABSPACE: function () {\n    const ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\";\n  },\n  // consume all whitespaces (excluding newlines)\n  consume_TABSPACE: function () {\n    while (this.offset < this.size) {\n      const ch = this.input();\n      if (!this.is_TABSPACE()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n    return this;\n  },\n  // check if current char can be a hexadecimal number\n  is_HEX: function () {\n    const ch = this._input.charCodeAt(this.offset - 1);\n    // 0 - 9\n    if (ch > 47 && ch < 58) return true;\n    // A - F\n    if (ch > 64 && ch < 71) return true;\n    // a - f\n    if (ch > 96 && ch < 103) return true;\n    // _ (code 95)\n    if (ch === 95) return true;\n    // else\n    return false;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * @private\n */\nfunction isNumber(n) {\n  return n != \".\" && n != \",\" && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * The PHP Parser class that build the AST tree from the lexer\n *\n * @class\n * @tutorial Parser\n * @property {Lexer} lexer - current lexer instance\n * @property {AST} ast - the AST factory instance\n * @property {Integer|String} token - current token\n * @property {Boolean} extractDoc - should extract documentation as AST node\n * @property {Boolean} extractTokens - should extract each token\n * @property {Boolean} suppressErrors - should ignore parsing errors and continue\n * @property {Boolean} debug - should output debug informations\n */\nconst parser = function (lexer, ast) {\n  this.lexer = lexer;\n  this.ast = ast;\n  this.tok = lexer.tok;\n  this.EOF = lexer.EOF;\n  this.token = null;\n  this.prev = null;\n  this.debug = false;\n  this.version = 704;\n  this.extractDoc = false;\n  this.extractTokens = false;\n  this.suppressErrors = false;\n  const mapIt = function (item) {\n    return [item, null];\n  };\n  this.entries = {\n    // reserved_non_modifiers\n    IDENTIFIER: new Map(\n      [\n        this.tok.T_ABSTRACT,\n        this.tok.T_ARRAY,\n        this.tok.T_AS,\n        this.tok.T_BREAK,\n        this.tok.T_CALLABLE,\n        this.tok.T_CASE,\n        this.tok.T_CATCH,\n        this.tok.T_CLASS,\n        this.tok.T_CLASS_C,\n        this.tok.T_CLONE,\n        this.tok.T_CONST,\n        this.tok.T_CONTINUE,\n        this.tok.T_DECLARE,\n        this.tok.T_DEFAULT,\n        this.tok.T_DIR,\n        this.tok.T_DO,\n        this.tok.T_ECHO,\n        this.tok.T_ELSE,\n        this.tok.T_ELSEIF,\n        this.tok.T_EMPTY,\n        this.tok.T_ENDDECLARE,\n        this.tok.T_ENDFOR,\n        this.tok.T_ENDFOREACH,\n        this.tok.T_ENDIF,\n        this.tok.T_ENDSWITCH,\n        this.tok.T_ENDWHILE,\n        this.tok.T_EVAL,\n        this.tok.T_EXIT,\n        this.tok.T_EXTENDS,\n        this.tok.T_FILE,\n        this.tok.T_FINAL,\n        this.tok.T_FINALLY,\n        this.tok.T_FN,\n        this.tok.T_FOR,\n        this.tok.T_FOREACH,\n        this.tok.T_FUNC_C,\n        this.tok.T_FUNCTION,\n        this.tok.T_GLOBAL,\n        this.tok.T_GOTO,\n        this.tok.T_IF,\n        this.tok.T_IMPLEMENTS,\n        this.tok.T_INCLUDE,\n        this.tok.T_INCLUDE_ONCE,\n        this.tok.T_INSTANCEOF,\n        this.tok.T_INSTEADOF,\n        this.tok.T_INTERFACE,\n        this.tok.T_ISSET,\n        this.tok.T_LINE,\n        this.tok.T_LIST,\n        this.tok.T_LOGICAL_AND,\n        this.tok.T_LOGICAL_OR,\n        this.tok.T_LOGICAL_XOR,\n        this.tok.T_METHOD_C,\n        this.tok.T_NAMESPACE,\n        this.tok.T_NEW,\n        this.tok.T_NS_C,\n        this.tok.T_PRINT,\n        this.tok.T_PRIVATE,\n        this.tok.T_PROTECTED,\n        this.tok.T_PUBLIC,\n        this.tok.T_REQUIRE,\n        this.tok.T_REQUIRE_ONCE,\n        this.tok.T_RETURN,\n        this.tok.T_STATIC,\n        this.tok.T_SWITCH,\n        this.tok.T_THROW,\n        this.tok.T_TRAIT,\n        this.tok.T_TRY,\n        this.tok.T_UNSET,\n        this.tok.T_USE,\n        this.tok.T_VAR,\n        this.tok.T_WHILE,\n        this.tok.T_YIELD,\n      ].map(mapIt)\n    ),\n    VARIABLE: new Map(\n      [\n        this.tok.T_VARIABLE,\n        \"$\",\n        \"&\",\n        this.tok.T_NS_SEPARATOR,\n        this.tok.T_STRING,\n        this.tok.T_NAMESPACE,\n        this.tok.T_STATIC,\n      ].map(mapIt)\n    ),\n    SCALAR: new Map(\n      [\n        this.tok.T_CONSTANT_ENCAPSED_STRING,\n        this.tok.T_START_HEREDOC,\n        this.tok.T_LNUMBER,\n        this.tok.T_DNUMBER,\n        this.tok.T_ARRAY,\n        \"[\",\n        this.tok.T_CLASS_C,\n        this.tok.T_TRAIT_C,\n        this.tok.T_FUNC_C,\n        this.tok.T_METHOD_C,\n        this.tok.T_LINE,\n        this.tok.T_FILE,\n        this.tok.T_DIR,\n        this.tok.T_NS_C,\n        '\"',\n        'b\"',\n        'B\"',\n        \"-\",\n        this.tok.T_NS_SEPARATOR,\n      ].map(mapIt)\n    ),\n    T_MAGIC_CONST: new Map(\n      [\n        this.tok.T_CLASS_C,\n        this.tok.T_TRAIT_C,\n        this.tok.T_FUNC_C,\n        this.tok.T_METHOD_C,\n        this.tok.T_LINE,\n        this.tok.T_FILE,\n        this.tok.T_DIR,\n        this.tok.T_NS_C,\n      ].map(mapIt)\n    ),\n    T_MEMBER_FLAGS: new Map(\n      [\n        this.tok.T_PUBLIC,\n        this.tok.T_PRIVATE,\n        this.tok.T_PROTECTED,\n        this.tok.T_STATIC,\n        this.tok.T_ABSTRACT,\n        this.tok.T_FINAL,\n      ].map(mapIt)\n    ),\n    EOS: new Map([\";\", this.EOF, this.tok.T_INLINE_HTML].map(mapIt)),\n    EXPR: new Map(\n      [\n        \"@\",\n        \"-\",\n        \"+\",\n        \"!\",\n        \"~\",\n        \"(\",\n        \"`\",\n        this.tok.T_LIST,\n        this.tok.T_CLONE,\n        this.tok.T_INC,\n        this.tok.T_DEC,\n        this.tok.T_NEW,\n        this.tok.T_ISSET,\n        this.tok.T_EMPTY,\n        this.tok.T_INCLUDE,\n        this.tok.T_INCLUDE_ONCE,\n        this.tok.T_REQUIRE,\n        this.tok.T_REQUIRE_ONCE,\n        this.tok.T_EVAL,\n        this.tok.T_INT_CAST,\n        this.tok.T_DOUBLE_CAST,\n        this.tok.T_STRING_CAST,\n        this.tok.T_ARRAY_CAST,\n        this.tok.T_OBJECT_CAST,\n        this.tok.T_BOOL_CAST,\n        this.tok.T_UNSET_CAST,\n        this.tok.T_EXIT,\n        this.tok.T_PRINT,\n        this.tok.T_YIELD,\n        this.tok.T_STATIC,\n        this.tok.T_FUNCTION,\n        this.tok.T_FN,\n        // using VARIABLES :\n        this.tok.T_VARIABLE,\n        \"$\",\n        this.tok.T_NS_SEPARATOR,\n        this.tok.T_STRING,\n        // using SCALAR :\n        this.tok.T_STRING, // @see variable.js line 45 > conflict with variable = shift/reduce :)\n        this.tok.T_CONSTANT_ENCAPSED_STRING,\n        this.tok.T_START_HEREDOC,\n        this.tok.T_LNUMBER,\n        this.tok.T_DNUMBER,\n        this.tok.T_ARRAY,\n        \"[\",\n        this.tok.T_CLASS_C,\n        this.tok.T_TRAIT_C,\n        this.tok.T_FUNC_C,\n        this.tok.T_METHOD_C,\n        this.tok.T_LINE,\n        this.tok.T_FILE,\n        this.tok.T_DIR,\n        this.tok.T_NS_C,\n        '\"',\n        'b\"',\n        'B\"',\n        \"-\",\n        this.tok.T_NS_SEPARATOR,\n      ].map(mapIt)\n    ),\n  };\n};\n\n/**\n * helper : gets a token name\n */\nparser.prototype.getTokenName = function (token) {\n  if (!isNumber(token)) {\n    return \"'\" + token + \"'\";\n  } else {\n    if (token == this.EOF) return \"the end of file (EOF)\";\n    return this.lexer.engine.tokens.values[token];\n  }\n};\n\n/**\n * main entry point : converts a source code to AST\n */\nparser.prototype.parse = function (code, filename) {\n  this._errors = [];\n  this.filename = filename || \"eval\";\n  this.currentNamespace = [\"\"];\n  if (this.extractDoc) {\n    this._docs = [];\n  } else {\n    this._docs = null;\n  }\n  if (this.extractTokens) {\n    this._tokens = [];\n  } else {\n    this._tokens = null;\n  }\n  this._docIndex = 0;\n  this._lastNode = null;\n  this.lexer.setInput(code);\n  this.lexer.all_tokens = this.extractTokens;\n  this.lexer.comment_tokens = this.extractDoc;\n  this.length = this.lexer._input.length;\n  this.innerList = false;\n  this.innerListForm = false;\n  const program = this.node(\"program\");\n  const childs = [];\n  this.next();\n  while (this.token != this.EOF) {\n    childs.push(this.read_start());\n  }\n  // append last comment\n  if (\n    childs.length === 0 &&\n    this.extractDoc &&\n    this._docs.length > this._docIndex\n  ) {\n    childs.push(this.node(\"noop\")());\n  }\n  // #176 : register latest position\n  this.prev = [\n    this.lexer.yylloc.last_line,\n    this.lexer.yylloc.last_column,\n    this.lexer.offset,\n  ];\n  const result = program(childs, this._errors, this._docs, this._tokens);\n  if (this.debug) {\n    const errors = this.ast.checkNodes();\n    if (errors.length > 0) {\n      errors.forEach(function (error) {\n        if (error.position) {\n          // eslint-disable-next-line no-console\n          console.log(\n            \"Node at line \" +\n              error.position.line +\n              \", column \" +\n              error.position.column\n          );\n        }\n        // eslint-disable-next-line no-console\n        console.log(error.stack.join(\"\\n\"));\n      });\n      throw new Error(\"Some nodes are not closed\");\n    }\n  }\n  return result;\n};\n\n/**\n * Raise an error\n */\nparser.prototype.raiseError = function (message, msgExpect, expect, token) {\n  message += \" on line \" + this.lexer.yylloc.first_line;\n  if (!this.suppressErrors) {\n    const err = new SyntaxError(\n      message,\n      this.filename,\n      this.lexer.yylloc.first_line\n    );\n    err.lineNumber = this.lexer.yylloc.first_line;\n    err.fileName = this.filename;\n    err.columnNumber = this.lexer.yylloc.first_column;\n    throw err;\n  }\n  // Error node :\n  const node = this.ast.prepare(\"error\", null, this)(\n    message,\n    token,\n    this.lexer.yylloc.first_line,\n    expect\n  );\n  this._errors.push(node);\n  return node;\n};\n\n/**\n * handling errors\n */\nparser.prototype.error = function (expect) {\n  let msg = \"Parse Error : syntax error\";\n  let token = this.getTokenName(this.token);\n  let msgExpect = \"\";\n\n  if (this.token !== this.EOF) {\n    if (isNumber(this.token)) {\n      let symbol = this.text();\n      if (symbol.length > 10) {\n        symbol = symbol.substring(0, 7) + \"...\";\n      }\n      token = \"'\" + symbol + \"' (\" + token + \")\";\n    }\n    msg += \", unexpected \" + token;\n  }\n  if (expect && !Array.isArray(expect)) {\n    if (isNumber(expect) || expect.length === 1) {\n      msgExpect = \", expecting \" + this.getTokenName(expect);\n    }\n    msg += msgExpect;\n  }\n  return this.raiseError(msg, msgExpect, expect, token);\n};\n\n/**\n * Creates a new AST node\n */\nparser.prototype.node = function (name) {\n  if (this.extractDoc) {\n    let docs = null;\n    if (this._docIndex < this._docs.length) {\n      docs = this._docs.slice(this._docIndex);\n      this._docIndex = this._docs.length;\n      if (this.debug) {\n        // eslint-disable-next-line no-console\n        console.log(new Error(\"Append docs on \" + name));\n        // eslint-disable-next-line no-console\n        console.log(docs);\n      }\n    }\n    const node = this.ast.prepare(name, docs, this);\n    /**\n     * TOKENS :\n     * node1 commentA token commmentB node2 commentC token commentD node3 commentE token\n     *\n     * AST :\n     * structure:S1 [\n     *    left: node1 ( trail: commentA ),\n     *    right: structure:S2 [\n     *       node2 (lead: commentB, trail: commentC),\n     *       node3 (lead: commentD)\n     *    ],\n     *    trail: commentE\n     * ]\n     *\n     * Algorithm :\n     *\n     * Attach the last comments on parent of current node\n     * If a new node is started and the parent has a trailing comment\n     * the move it on previous node\n     *\n     * start S2\n     * start node1\n     * consume node1 & set commentA as trailingComment on S2\n     * start S2\n     * S1 has a trailingComment, attach it on node1\n     * ...\n     * NOTE : As the trailingComment Behavior depends on AST, it will be build on\n     * the AST layer - last child node will keep it's trailingComment nodes\n     */\n    node.postBuild = function (self) {\n      if (this._docIndex < this._docs.length) {\n        if (this._lastNode) {\n          const offset = this.prev[2];\n          let max = this._docIndex;\n          for (; max < this._docs.length; max++) {\n            if (this._docs[max].offset > offset) {\n              break;\n            }\n          }\n          if (max > this._docIndex) {\n            // inject trailing comment on child node\n            this._lastNode.setTrailingComments(\n              this._docs.slice(this._docIndex, max)\n            );\n            this._docIndex = max;\n          }\n        } else if (this.token === this.EOF) {\n          // end of content\n          self.setTrailingComments(this._docs.slice(this._docIndex));\n          this._docIndex = this._docs.length;\n        }\n      }\n      this._lastNode = self;\n    }.bind(this);\n    return node;\n  }\n  return this.ast.prepare(name, null, this);\n};\n\n/**\n * expects an end of statement or end of file\n * @return {boolean}\n */\nparser.prototype.expectEndOfStatement = function (node) {\n  if (this.token === \";\") {\n    // include only real ';' statements\n    // https://github.com/glayzzle/php-parser/issues/164\n    if (node && this.lexer.yytext === \";\") {\n      node.includeToken(this);\n    }\n  } else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {\n    this.error(\";\");\n    return false;\n  }\n  this.next();\n  return true;\n};\n\n/** outputs some debug information on current token **/\nconst ignoreStack = [\"parser.next\", \"parser.node\", \"parser.showlog\"];\nparser.prototype.showlog = function () {\n  const stack = new Error().stack.split(\"\\n\");\n  let line;\n  for (let offset = 2; offset < stack.length; offset++) {\n    line = stack[offset].trim();\n    let found = false;\n    for (let i = 0; i < ignoreStack.length; i++) {\n      if (line.substring(3, 3 + ignoreStack[i].length) === ignoreStack[i]) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      break;\n    }\n  }\n  // eslint-disable-next-line no-console\n  console.log(\n    \"Line \" +\n      this.lexer.yylloc.first_line +\n      \" : \" +\n      this.getTokenName(this.token) +\n      \">\" +\n      this.lexer.yytext +\n      \"<\" +\n      \" @-->\" +\n      line\n  );\n  return this;\n};\n\n/**\n * Force the parser to check the current token.\n *\n * If the current token does not match to expected token,\n * the an error will be raised.\n *\n * If the suppressError mode is activated, then the error will\n * be added to the program error stack and this function will return `false`.\n *\n * @param {String|Number} token\n * @return {boolean}\n * @throws Error\n */\nparser.prototype.expect = function (token) {\n  if (Array.isArray(token)) {\n    if (token.indexOf(this.token) === -1) {\n      this.error(token);\n      return false;\n    }\n  } else if (this.token != token) {\n    this.error(token);\n    return false;\n  }\n  return true;\n};\n\n/**\n * Returns the current token contents\n * @return {String}\n */\nparser.prototype.text = function () {\n  return this.lexer.yytext;\n};\n\n/** consume the next token **/\nparser.prototype.next = function () {\n  // prepare the back command\n  if (this.token !== \";\" || this.lexer.yytext === \";\") {\n    // ignore '?>' from automated resolution\n    // https://github.com/glayzzle/php-parser/issues/168\n    this.prev = [\n      this.lexer.yylloc.last_line,\n      this.lexer.yylloc.last_column,\n      this.lexer.offset,\n    ];\n  }\n\n  // eating the token\n  this.lex();\n\n  // showing the debug\n  if (this.debug) {\n    this.showlog();\n  }\n\n  // handling comments\n  if (this.extractDoc) {\n    while (\n      this.token === this.tok.T_COMMENT ||\n      this.token === this.tok.T_DOC_COMMENT\n    ) {\n      // APPEND COMMENTS\n      if (this.token === this.tok.T_COMMENT) {\n        this._docs.push(this.read_comment());\n      } else {\n        this._docs.push(this.read_doc_comment());\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Eating a token\n */\nparser.prototype.lex = function () {\n  // append on token stack\n  if (this.extractTokens) {\n    do {\n      // the token\n      this.token = this.lexer.lex() || this.EOF;\n      if (this.token === this.EOF) return this;\n      let entry = this.lexer.yytext;\n      if (this.lexer.engine.tokens.values.hasOwnProperty(this.token)) {\n        entry = [\n          this.lexer.engine.tokens.values[this.token],\n          entry,\n          this.lexer.yylloc.first_line,\n          this.lexer.yylloc.first_offset,\n          this.lexer.offset,\n        ];\n      } else {\n        entry = [\n          null,\n          entry,\n          this.lexer.yylloc.first_line,\n          this.lexer.yylloc.first_offset,\n          this.lexer.offset,\n        ];\n      }\n      this._tokens.push(entry);\n      if (this.token === this.tok.T_CLOSE_TAG) {\n        // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n        this.token = \";\";\n        return this;\n      } else if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO) {\n        this.token = this.tok.T_ECHO;\n        return this;\n      }\n    } while (\n      this.token === this.tok.T_WHITESPACE || // ignore white space\n      (!this.extractDoc &&\n        (this.token === this.tok.T_COMMENT || // ignore single lines comments\n          this.token === this.tok.T_DOC_COMMENT)) || // ignore doc comments\n      // ignore open tags\n      this.token === this.tok.T_OPEN_TAG\n    );\n  } else {\n    this.token = this.lexer.lex() || this.EOF;\n  }\n  return this;\n};\n\n/**\n * Check if token is of specified type\n */\nparser.prototype.is = function (type) {\n  if (Array.isArray(type)) {\n    return type.indexOf(this.token) !== -1;\n  }\n  return this.entries[type].has(this.token);\n};\n\n// extends the parser with syntax files\n[\n  require(\"./parser/array.js\"),\n  require(\"./parser/class.js\"),\n  require(\"./parser/comment.js\"),\n  require(\"./parser/expr.js\"),\n  require(\"./parser/function.js\"),\n  require(\"./parser/if.js\"),\n  require(\"./parser/loops.js\"),\n  require(\"./parser/main.js\"),\n  require(\"./parser/namespace.js\"),\n  require(\"./parser/scalar.js\"),\n  require(\"./parser/statement.js\"),\n  require(\"./parser/switch.js\"),\n  require(\"./parser/try.js\"),\n  require(\"./parser/utils.js\"),\n  require(\"./parser/variable.js\"),\n].forEach(function (ext) {\n  for (const k in ext) {\n    if (parser.prototype.hasOwnProperty(k)) {\n      // @see https://github.com/glayzzle/php-parser/issues/234\n      throw new Error(\"Function \" + k + \" is already defined - collision\");\n    }\n    parser.prototype[k] = ext[k];\n  }\n});\n\nmodule.exports = parser;\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Parse an array\n   * ```ebnf\n   * array ::= T_ARRAY '(' array_pair_list ')' |\n   *   '[' array_pair_list ']'\n   * ```\n   */\n  read_array: function () {\n    let expect = null;\n    let shortForm = false;\n    const result = this.node(\"array\");\n\n    if (this.token === this.tok.T_ARRAY) {\n      this.next().expect(\"(\");\n      expect = \")\";\n    } else {\n      shortForm = true;\n      expect = \"]\";\n    }\n    let items = [];\n    if (this.next().token !== expect) {\n      items = this.read_array_pair_list(shortForm);\n    }\n    this.expect(expect);\n    this.next();\n    return result(shortForm, items);\n  },\n  /**\n   * Reads an array of items\n   * ```ebnf\n   * array_pair_list ::= array_pair (',' array_pair?)*\n   * ```\n   */\n  read_array_pair_list: function (shortForm) {\n    const self = this;\n    return this.read_list(\n      function () {\n        return self.read_array_pair(shortForm);\n      },\n      \",\",\n      true\n    );\n  },\n  /**\n   * Reads an entry\n   * array_pair:\n   *  expr T_DOUBLE_ARROW expr\n   *  | expr\n   *  | expr T_DOUBLE_ARROW '&' variable\n   *  | '&' variable\n   *  | expr T_DOUBLE_ARROW T_LIST '(' array_pair_list ')'\n   *  | T_LIST '(' array_pair_list ')'\n   */\n  read_array_pair: function (shortForm) {\n    if (\n      (!shortForm && this.token === \")\") ||\n      (shortForm && this.token === \"]\")\n    ) {\n      return;\n    }\n\n    if (this.token === \",\") {\n      return this.node(\"noop\")();\n    }\n\n    const entry = this.node(\"entry\");\n\n    let key = null;\n    let value = null;\n    let byRef = false;\n    let unpack = false;\n\n    if (this.token === \"&\") {\n      this.next();\n      byRef = true;\n      value = this.read_variable(true, false);\n    } else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704) {\n      this.next();\n      if (this.token === \"&\") {\n        this.error();\n      }\n      unpack = true;\n      value = this.read_expr();\n    } else {\n      const expr = this.read_expr();\n\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        this.next();\n        key = expr;\n\n        if (this.token === \"&\") {\n          this.next();\n          byRef = true;\n          value = this.read_variable(true, false);\n        } else {\n          value = this.read_expr();\n        }\n      } else {\n        value = expr;\n      }\n    }\n\n    return entry(key, value, byRef, unpack);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * reading a class\n   * ```ebnf\n   * class ::= class_scope? T_CLASS T_STRING (T_EXTENDS NAMESPACE_NAME)? (T_IMPLEMENTS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' CLASS_BODY '}'\n   * ```\n   */\n  read_class_declaration_statement: function () {\n    const result = this.node(\"class\");\n    const flag = this.read_class_modifiers();\n    // graceful mode : ignore token & go next\n    if (this.token !== this.tok.T_CLASS) {\n      this.error(this.tok.T_CLASS);\n      this.next();\n      return null;\n    }\n    this.next().expect(this.tok.T_STRING);\n    let propName = this.node(\"identifier\");\n    const name = this.text();\n    this.next();\n    propName = propName(name);\n    const propExtends = this.read_extends_from();\n    const propImplements = this.read_implements_list();\n    this.expect(\"{\");\n    const body = this.next().read_class_body();\n    return result(propName, propExtends, propImplements, body, flag);\n  },\n\n  read_class_modifiers: function () {\n    return [0, 0, this.read_class_modifier()];\n  },\n\n  read_class_modifier: function () {\n    const result = 0;\n\n    if (this.token === this.tok.T_ABSTRACT) {\n      this.next();\n      return 1;\n    } else if (this.token === this.tok.T_FINAL) {\n      this.next();\n      return 2;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a class body\n   * ```ebnf\n   *   class_body ::= (member_flags? (T_VAR | T_STRING | T_FUNCTION))*\n   * ```\n   */\n  read_class_body: function () {\n    let result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      }\n\n      // check T_USE trait\n      if (this.token === this.tok.T_USE) {\n        result = result.concat(this.read_trait_use_statement());\n        continue;\n      }\n\n      // read member flags\n      const flags = this.read_member_flags(false);\n\n      // check constant\n      if (this.token === this.tok.T_CONST) {\n        const constants = this.read_constant_list(flags);\n        if (this.expect(\";\")) {\n          this.next();\n        }\n        result = result.concat(constants);\n        continue;\n      }\n\n      // jump over T_VAR then land on T_VARIABLE\n      if (this.token === this.tok.T_VAR) {\n        this.next().expect(this.tok.T_VARIABLE);\n        flags[0] = null; // public (as null)\n        flags[1] = 0; // non static var\n      }\n\n      if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        result.push(this.read_function(false, flags));\n      } else if (\n        this.token === this.tok.T_VARIABLE ||\n        // support https://wiki.php.net/rfc/typed_properties_v2\n        (this.version >= 704 &&\n          (this.token === \"?\" ||\n            this.token === this.tok.T_CALLABLE ||\n            this.token === this.tok.T_ARRAY ||\n            this.token === this.tok.T_NS_SEPARATOR ||\n            this.token === this.tok.T_STRING ||\n            this.token === this.tok.T_NAMESPACE))\n      ) {\n        // reads a variable\n        const variables = this.read_variable_list(flags);\n        this.expect(\";\");\n        this.next();\n        result = result.concat(variables);\n      } else {\n        // raise an error\n        this.error([\n          this.tok.T_CONST,\n          this.tok.T_VARIABLE,\n          this.tok.T_FUNCTION,\n        ]);\n        // ignore token\n        this.next();\n      }\n    }\n    this.expect(\"}\");\n    this.next();\n    return result;\n  },\n  /**\n   * Reads variable list\n   * ```ebnf\n   *  variable_list ::= (variable_declaration ',')* variable_declaration\n   * ```\n   */\n  read_variable_list: function (flags) {\n    const result = this.node(\"propertystatement\");\n\n    const properties = this.read_list(\n      /**\n       * Reads a variable declaration\n       *\n       * ```ebnf\n       *  variable_declaration ::= T_VARIABLE '=' scalar\n       * ```\n       */\n      function read_variable_declaration() {\n        const result = this.node(\"property\");\n        const [nullable, type] = this.read_optional_type();\n        this.expect(this.tok.T_VARIABLE);\n        let propName = this.node(\"identifier\");\n        const name = this.text().substring(1); // ignore $\n        this.next();\n        propName = propName(name);\n        if (this.token === \";\" || this.token === \",\") {\n          return result(propName, null, nullable, type);\n        } else if (this.token === \"=\") {\n          // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L815\n          return result(propName, this.next().read_expr(), nullable, type);\n        } else {\n          this.expect([\",\", \";\", \"=\"]);\n          return result(propName, null, nullable, type);\n        }\n      },\n      \",\"\n    );\n\n    return result(null, properties, flags);\n  },\n  /**\n   * Reads constant list\n   * ```ebnf\n   *  constant_list ::= T_CONST (constant_declaration ',')* constant_declaration\n   * ```\n   */\n  read_constant_list: function (flags) {\n    if (this.expect(this.tok.T_CONST)) {\n      this.next();\n    }\n    const result = this.node(\"classconstant\");\n    const items = this.read_list(\n      /**\n       * Reads a constant declaration\n       *\n       * ```ebnf\n       *  constant_declaration ::= (T_STRING | IDENTIFIER) '=' expr\n       * ```\n       * @return {Constant} [:link:](AST.md#constant)\n       */\n      function read_constant_declaration() {\n        const result = this.node(\"constant\");\n        let constName = null;\n        let value = null;\n        if (\n          this.token === this.tok.T_STRING ||\n          (this.version >= 700 && this.is(\"IDENTIFIER\"))\n        ) {\n          constName = this.node(\"identifier\");\n          const name = this.text();\n          this.next();\n          constName = constName(name);\n        } else {\n          this.expect(\"IDENTIFIER\");\n        }\n        if (this.expect(\"=\")) {\n          value = this.next().read_expr();\n        }\n        return result(constName, value);\n      },\n      \",\"\n    );\n\n    return result(null, items, flags);\n  },\n  /**\n   * Read member flags\n   * @return array\n   *  1st index : 0 => public, 1 => protected, 2 => private\n   *  2nd index : 0 => instance member, 1 => static member\n   *  3rd index : 0 => normal, 1 => abstract member, 2 => final member\n   */\n  read_member_flags: function (asInterface) {\n    const result = [-1, -1, -1];\n    if (this.is(\"T_MEMBER_FLAGS\")) {\n      let idx = 0,\n        val = 0;\n      do {\n        switch (this.token) {\n          case this.tok.T_PUBLIC:\n            idx = 0;\n            val = 0;\n            break;\n          case this.tok.T_PROTECTED:\n            idx = 0;\n            val = 1;\n            break;\n          case this.tok.T_PRIVATE:\n            idx = 0;\n            val = 2;\n            break;\n          case this.tok.T_STATIC:\n            idx = 1;\n            val = 1;\n            break;\n          case this.tok.T_ABSTRACT:\n            idx = 2;\n            val = 1;\n            break;\n          case this.tok.T_FINAL:\n            idx = 2;\n            val = 2;\n            break;\n        }\n        if (asInterface) {\n          if (idx == 0 && val == 2) {\n            // an interface can't be private\n            this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]);\n            val = -1;\n          } else if (idx == 2 && val == 1) {\n            // an interface cant be abstract\n            this.error();\n            val = -1;\n          }\n        }\n        if (result[idx] !== -1) {\n          // already defined flag\n          this.error();\n        } else if (val !== -1) {\n          result[idx] = val;\n        }\n      } while (this.next().is(\"T_MEMBER_FLAGS\"));\n    }\n\n    if (result[1] == -1) result[1] = 0;\n    if (result[2] == -1) result[2] = 0;\n    return result;\n  },\n\n  /**\n   * optional_type:\n   *\t  /- empty -/\t{ $$ = NULL; }\n   *   |\ttype_expr\t{ $$ = $1; }\n   * ;\n   *\n   * type_expr:\n   *\t\ttype\t\t{ $$ = $1; }\n   *\t|\t'?' type\t{ $$ = $2; $$->attr |= ZEND_TYPE_NULLABLE; }\n   *\t|\tunion_type\t{ $$ = $1; }\n   * ;\n   *\n   * type:\n   * \t\tT_ARRAY\t\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_ARRAY); }\n   * \t|\tT_CALLABLE\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_CALLABLE); }\n   * \t|\tname\t\t{ $$ = $1; }\n   * ;\n   *\n   * union_type:\n   * \t\ttype '|' type       { $$ = zend_ast_create_list(2, ZEND_AST_TYPE_UNION, $1, $3); }\n   * \t|\tunion_type '|' type { $$ = zend_ast_list_add($1, $3); }\n   * ;\n   */\n  read_optional_type: function () {\n    let nullable = false;\n    if (this.token === \"?\") {\n      nullable = true;\n      this.next();\n    }\n    let type = this.read_type();\n    if (nullable && !type) {\n      this.raiseError(\n        \"Expecting a type definition combined with nullable operator\"\n      );\n    }\n    if (!nullable && !type) {\n      return [false, null];\n    }\n    if (this.token === \"|\") {\n      type = [type];\n      do {\n        this.next();\n        const variant = this.read_type();\n        if (!variant) {\n          this.raiseError(\"Expecting a type definition\");\n          break;\n        }\n        type.push(variant);\n      } while (this.token === \"|\");\n    }\n    return [nullable, type];\n  },\n\n  /**\n   * reading an interface\n   * ```ebnf\n   * interface ::= T_INTERFACE T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' INTERFACE_BODY '}'\n   * ```\n   */\n  read_interface_declaration_statement: function () {\n    const result = this.node(\"interface\");\n    if (this.token !== this.tok.T_INTERFACE) {\n      this.error(this.tok.T_INTERFACE);\n      this.next();\n      return null;\n    }\n    this.next().expect(this.tok.T_STRING);\n    let propName = this.node(\"identifier\");\n    const name = this.text();\n    this.next();\n    propName = propName(name);\n    const propExtends = this.read_interface_extends_list();\n    this.expect(\"{\");\n    const body = this.next().read_interface_body();\n    return result(propName, propExtends, body);\n  },\n  /**\n   * Reads an interface body\n   * ```ebnf\n   *   interface_body ::= (member_flags? (T_CONST | T_FUNCTION))*\n   * ```\n   */\n  read_interface_body: function () {\n    let result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      }\n\n      // read member flags\n      const flags = this.read_member_flags(true);\n\n      // check constant\n      if (this.token == this.tok.T_CONST) {\n        const constants = this.read_constant_list(flags);\n        if (this.expect(\";\")) {\n          this.next();\n        }\n        result = result.concat(constants);\n      } else if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        const method = this.read_function_declaration(2, flags);\n        method.parseFlags(flags);\n        result.push(method);\n        if (this.expect(\";\")) {\n          this.next();\n        }\n      } else {\n        // raise an error\n        this.error([this.tok.T_CONST, this.tok.T_FUNCTION]);\n        this.next();\n      }\n    }\n    if (this.expect(\"}\")) {\n      this.next();\n    }\n    return result;\n  },\n  /**\n   * reading a trait\n   * ```ebnf\n   * trait ::= T_TRAIT T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' FUNCTION* '}'\n   * ```\n   */\n  read_trait_declaration_statement: function () {\n    const result = this.node(\"trait\");\n    // graceful mode : ignore token & go next\n    if (this.token !== this.tok.T_TRAIT) {\n      this.error(this.tok.T_TRAIT);\n      this.next();\n      return null;\n    }\n    this.next().expect(this.tok.T_STRING);\n    let propName = this.node(\"identifier\");\n    const name = this.text();\n    this.next();\n    propName = propName(name);\n    this.expect(\"{\");\n    const body = this.next().read_class_body();\n    return result(propName, body);\n  },\n  /**\n   * reading a use statement\n   * ```ebnf\n   * trait_use_statement ::= namespace_name (',' namespace_name)* ('{' trait_use_alias '}')?\n   * ```\n   */\n  read_trait_use_statement: function () {\n    // defines use statements\n    const node = this.node(\"traituse\");\n    this.expect(this.tok.T_USE) && this.next();\n    const traits = [this.read_namespace_name()];\n    let adaptations = null;\n    while (this.token === \",\") {\n      traits.push(this.next().read_namespace_name());\n    }\n    if (this.token === \"{\") {\n      adaptations = [];\n      // defines alias statements\n      while (this.next().token !== this.EOF) {\n        if (this.token === \"}\") break;\n        adaptations.push(this.read_trait_use_alias());\n        this.expect(\";\");\n      }\n      if (this.expect(\"}\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    }\n    return node(traits, adaptations);\n  },\n  /**\n   * Reading trait alias\n   * ```ebnf\n   * trait_use_alias ::= namespace_name ( T_DOUBLE_COLON T_STRING )? (T_INSTEADOF namespace_name) | (T_AS member_flags? T_STRING)\n   * ```\n   * name list : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L303\n   * trait adaptation : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L742\n   */\n  read_trait_use_alias: function () {\n    const node = this.node();\n    let trait = null;\n    let method;\n\n    if (this.is(\"IDENTIFIER\")) {\n      method = this.node(\"identifier\");\n      const methodName = this.text();\n      this.next();\n      method = method(methodName);\n    } else {\n      method = this.read_namespace_name();\n\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        this.next();\n        if (\n          this.token === this.tok.T_STRING ||\n          (this.version >= 700 && this.is(\"IDENTIFIER\"))\n        ) {\n          trait = method;\n          method = this.node(\"identifier\");\n          const methodName = this.text();\n          this.next();\n          method = method(methodName);\n        } else {\n          this.expect(this.tok.T_STRING);\n        }\n      } else {\n        // convert identifier as string\n        method = method.name;\n      }\n    }\n\n    // handle trait precedence\n    if (this.token === this.tok.T_INSTEADOF) {\n      return node(\n        \"traitprecedence\",\n        trait,\n        method,\n        this.next().read_name_list()\n      );\n    } else if (this.token === this.tok.T_AS) {\n      // handle trait alias\n      let flags = null;\n      let alias = null;\n      if (this.next().is(\"T_MEMBER_FLAGS\")) {\n        flags = this.read_member_flags();\n      }\n\n      if (\n        this.token === this.tok.T_STRING ||\n        (this.version >= 700 && this.is(\"IDENTIFIER\"))\n      ) {\n        alias = this.node(\"identifier\");\n        const name = this.text();\n        this.next();\n        alias = alias(name);\n      } else if (flags === false) {\n        // no visibility flags and no name => too bad\n        this.expect(this.tok.T_STRING);\n      }\n\n      return node(\"traitalias\", trait, method, alias, flags);\n    }\n\n    // handle errors\n    this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]);\n    return node(\"traitalias\", trait, method, null, null);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   *  Comments with // or # or / * ... * /\n   */\n  read_comment: function () {\n    const text = this.text();\n    let result = this.ast.prepare(\n      text.substring(0, 2) === \"/*\" ? \"commentblock\" : \"commentline\",\n      null,\n      this\n    );\n    const offset = this.lexer.yylloc.first_offset;\n    // handle location on comment\n    const prev = this.prev;\n    this.prev = [\n      this.lexer.yylloc.last_line,\n      this.lexer.yylloc.last_column,\n      this.lexer.offset,\n    ];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  },\n  /**\n   * Comments with / ** ... * /\n   */\n  read_doc_comment: function () {\n    let result = this.ast.prepare(\"commentblock\", null, this);\n    const offset = this.lexer.yylloc.first_offset;\n    const text = this.text();\n    const prev = this.prev;\n    this.prev = [\n      this.lexer.yylloc.last_line,\n      this.lexer.yylloc.last_column,\n      this.lexer.offset,\n    ];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  read_expr: function (expr) {\n    const result = this.node();\n    if (this.token === \"@\") {\n      if (!expr) {\n        expr = this.next().read_expr();\n      }\n      return result(\"silent\", expr);\n    }\n    if (!expr) {\n      expr = this.read_expr_item();\n    }\n    // binary operations\n    if (this.token === \"|\")\n      return result(\"bin\", \"|\", expr, this.next().read_expr());\n    if (this.token === \"&\")\n      return result(\"bin\", \"&\", expr, this.next().read_expr());\n    if (this.token === \"^\")\n      return result(\"bin\", \"^\", expr, this.next().read_expr());\n    if (this.token === \".\")\n      return result(\"bin\", \".\", expr, this.next().read_expr());\n    if (this.token === \"+\")\n      return result(\"bin\", \"+\", expr, this.next().read_expr());\n    if (this.token === \"-\")\n      return result(\"bin\", \"-\", expr, this.next().read_expr());\n    if (this.token === \"*\")\n      return result(\"bin\", \"*\", expr, this.next().read_expr());\n    if (this.token === \"/\")\n      return result(\"bin\", \"/\", expr, this.next().read_expr());\n    if (this.token === \"%\")\n      return result(\"bin\", \"%\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_POW)\n      return result(\"bin\", \"**\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SL)\n      return result(\"bin\", \"<<\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SR)\n      return result(\"bin\", \">>\", expr, this.next().read_expr());\n    // more binary operations (formerly bool)\n    if (this.token === this.tok.T_BOOLEAN_OR)\n      return result(\"bin\", \"||\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_OR)\n      return result(\"bin\", \"or\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_BOOLEAN_AND)\n      return result(\"bin\", \"&&\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_AND)\n      return result(\"bin\", \"and\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_XOR)\n      return result(\"bin\", \"xor\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_IDENTICAL)\n      return result(\"bin\", \"===\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_IDENTICAL)\n      return result(\"bin\", \"!==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_EQUAL)\n      return result(\"bin\", \"==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_EQUAL)\n      return result(\"bin\", \"!=\", expr, this.next().read_expr());\n    if (this.token === \"<\")\n      return result(\"bin\", \"<\", expr, this.next().read_expr());\n    if (this.token === \">\")\n      return result(\"bin\", \">\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL)\n      return result(\"bin\", \"<=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_GREATER_OR_EQUAL)\n      return result(\"bin\", \">=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SPACESHIP)\n      return result(\"bin\", \"<=>\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_INSTANCEOF) {\n      expr = result(\n        \"bin\",\n        \"instanceof\",\n        expr,\n        this.next().read_class_name_reference()\n      );\n      if (\n        this.token !== \";\" &&\n        this.token !== this.tok.T_INLINE_HTML &&\n        this.token !== this.EOF\n      ) {\n        expr = this.read_expr(expr);\n      }\n    }\n\n    // extra operations :\n    // $username = $_GET['user'] ?? 'nobody';\n    if (this.token === this.tok.T_COALESCE)\n      return result(\"bin\", \"??\", expr, this.next().read_expr());\n\n    // extra operations :\n    // $username = $_GET['user'] ? true : false;\n    if (this.token === \"?\") {\n      let trueArg = null;\n      if (this.next().token !== \":\") {\n        trueArg = this.read_expr();\n      }\n      this.expect(\":\") && this.next();\n      return result(\"retif\", expr, trueArg, this.read_expr());\n    } else {\n      // see #193\n      result.destroy(expr);\n    }\n\n    return expr;\n  },\n\n  /**\n   * Reads a cast expression\n   */\n  read_expr_cast: function (type) {\n    return this.node(\"cast\")(type, this.text(), this.next().read_expr());\n  },\n\n  /**\n   * Read a isset variable\n   */\n  read_isset_variable: function () {\n    return this.read_expr();\n  },\n\n  /**\n   * Reads isset variables\n   */\n  read_isset_variables: function () {\n    return this.read_function_list(this.read_isset_variable, \",\");\n  },\n\n  /*\n   * Reads internal PHP functions\n   */\n  read_internal_functions_in_yacc: function () {\n    let result = null;\n    switch (this.token) {\n      case this.tok.T_ISSET:\n        {\n          result = this.node(\"isset\");\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n          const variables = this.read_isset_variables();\n          if (this.expect(\")\")) {\n            this.next();\n          }\n          result = result(variables);\n        }\n        break;\n      case this.tok.T_EMPTY:\n        {\n          result = this.node(\"empty\");\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n          const expression = this.read_expr();\n          if (this.expect(\")\")) {\n            this.next();\n          }\n          result = result(expression);\n        }\n        break;\n      case this.tok.T_INCLUDE:\n        result = this.node(\"include\")(false, false, this.next().read_expr());\n        break;\n      case this.tok.T_INCLUDE_ONCE:\n        result = this.node(\"include\")(true, false, this.next().read_expr());\n        break;\n      case this.tok.T_EVAL:\n        {\n          result = this.node(\"eval\");\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n          const expr = this.read_expr();\n          if (this.expect(\")\")) {\n            this.next();\n          }\n          result = result(expr);\n        }\n        break;\n      case this.tok.T_REQUIRE:\n        result = this.node(\"include\")(false, true, this.next().read_expr());\n        break;\n      case this.tok.T_REQUIRE_ONCE:\n        result = this.node(\"include\")(true, true, this.next().read_expr());\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads optional expression\n   */\n  read_optional_expr: function (stopToken) {\n    if (this.token !== stopToken) {\n      return this.read_expr();\n    }\n\n    return null;\n  },\n\n  /**\n   * Reads exit expression\n   */\n  read_exit_expr: function () {\n    let expression = null;\n\n    if (this.token === \"(\") {\n      this.next();\n      expression = this.read_optional_expr(\")\");\n      this.expect(\")\") && this.next();\n    }\n\n    return expression;\n  },\n\n  /**\n   * ```ebnf\n   * Reads an expression\n   *  expr ::= @todo\n   * ```\n   */\n  read_expr_item: function () {\n    let result, expr;\n    if (this.token === \"+\")\n      return this.node(\"unary\")(\"+\", this.next().read_expr());\n    if (this.token === \"-\")\n      return this.node(\"unary\")(\"-\", this.next().read_expr());\n    if (this.token === \"!\")\n      return this.node(\"unary\")(\"!\", this.next().read_expr());\n    if (this.token === \"~\")\n      return this.node(\"unary\")(\"~\", this.next().read_expr());\n\n    if (this.token === \"(\") {\n      expr = this.next().read_expr();\n      expr.parenthesizedExpression = true;\n      this.expect(\")\") && this.next();\n      return this.handleDereferencable(expr);\n    }\n\n    if (this.token === \"`\") {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1048\n      return this.read_encapsed_string(\"`\");\n    }\n\n    if (this.token === this.tok.T_LIST) {\n      let assign = null;\n      const isInner = this.innerList;\n      result = this.node(\"list\");\n      if (!isInner) {\n        assign = this.node(\"assign\");\n      }\n      if (this.next().expect(\"(\")) {\n        this.next();\n      }\n\n      if (!this.innerList) this.innerList = true;\n\n      // reads inner items\n      const assignList = this.read_array_pair_list(false);\n      if (this.expect(\")\")) {\n        this.next();\n      }\n\n      // check if contains at least one assignment statement\n      let hasItem = false;\n      for (let i = 0; i < assignList.length; i++) {\n        if (assignList[i] !== null && assignList[i].kind !== \"noop\") {\n          hasItem = true;\n          break;\n        }\n      }\n      if (!hasItem) {\n        this.raiseError(\n          \"Fatal Error :  Cannot use empty list on line \" +\n            this.lexer.yylloc.first_line\n        );\n      }\n\n      // handles the node resolution\n      if (!isInner) {\n        this.innerList = false;\n        if (this.expect(\"=\")) {\n          return assign(\n            result(assignList, false),\n            this.next().read_expr(),\n            \"=\"\n          );\n        } else {\n          // error fallback : list($a, $b);\n          return result(assignList, false);\n        }\n      } else {\n        return result(assignList, false);\n      }\n    }\n\n    if (this.token === this.tok.T_CLONE)\n      return this.node(\"clone\")(this.next().read_expr());\n\n    switch (this.token) {\n      case this.tok.T_INC:\n        return this.node(\"pre\")(\"+\", this.next().read_variable(false, false));\n\n      case this.tok.T_DEC:\n        return this.node(\"pre\")(\"-\", this.next().read_variable(false, false));\n\n      case this.tok.T_NEW:\n        return this.read_new_expr();\n\n      case this.tok.T_ISSET:\n      case this.tok.T_EMPTY:\n      case this.tok.T_INCLUDE:\n      case this.tok.T_INCLUDE_ONCE:\n      case this.tok.T_EVAL:\n      case this.tok.T_REQUIRE:\n      case this.tok.T_REQUIRE_ONCE:\n        return this.read_internal_functions_in_yacc();\n      case this.tok.T_INT_CAST:\n        return this.read_expr_cast(\"int\");\n\n      case this.tok.T_DOUBLE_CAST:\n        return this.read_expr_cast(\"float\");\n\n      case this.tok.T_STRING_CAST:\n        return this.read_expr_cast(\n          this.text().indexOf(\"binary\") !== -1 ? \"binary\" : \"string\"\n        );\n\n      case this.tok.T_ARRAY_CAST:\n        return this.read_expr_cast(\"array\");\n\n      case this.tok.T_OBJECT_CAST:\n        return this.read_expr_cast(\"object\");\n\n      case this.tok.T_BOOL_CAST:\n        return this.read_expr_cast(\"bool\");\n\n      case this.tok.T_UNSET_CAST:\n        return this.read_expr_cast(\"unset\");\n\n      case this.tok.T_EXIT: {\n        const useDie = this.lexer.yytext.toLowerCase() === \"die\";\n        result = this.node(\"exit\");\n        this.next();\n        const expression = this.read_exit_expr();\n        return result(expression, useDie);\n      }\n\n      case this.tok.T_PRINT:\n        return this.node(\"print\")(this.next().read_expr());\n\n      // T_YIELD (expr (T_DOUBLE_ARROW expr)?)?\n      case this.tok.T_YIELD: {\n        let value = null;\n        let key = null;\n        result = this.node(\"yield\");\n        if (this.next().is(\"EXPR\")) {\n          // reads the yield return value\n          value = this.read_expr();\n          if (this.token === this.tok.T_DOUBLE_ARROW) {\n            // reads the yield returned key\n            key = value;\n            value = this.next().read_expr();\n          }\n        }\n        return result(value, key);\n      }\n\n      // T_YIELD_FROM expr\n      case this.tok.T_YIELD_FROM:\n        result = this.node(\"yieldfrom\");\n        expr = this.next().read_expr();\n        return result(expr);\n\n      case this.tok.T_FN:\n      case this.tok.T_FUNCTION:\n        return this.read_inline_function();\n\n      case this.tok.T_STATIC: {\n        const backup = [this.token, this.lexer.getState()];\n        this.next();\n        if (\n          this.token === this.tok.T_FUNCTION ||\n          (this.version >= 704 && this.token === this.tok.T_FN)\n        ) {\n          // handles static function\n          return this.read_inline_function([0, 1, 0]);\n        } else {\n          // rollback\n          this.lexer.tokens.push(backup);\n          this.next();\n        }\n      }\n    }\n\n    // SCALAR | VARIABLE\n    if (this.is(\"VARIABLE\")) {\n      result = this.node();\n      expr = this.read_variable(false, false);\n\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L877\n      // should accept only a variable\n      const isConst =\n        expr.kind === \"identifier\" ||\n        (expr.kind === \"staticlookup\" && expr.offset.kind === \"identifier\");\n\n      // VARIABLES SPECIFIC OPERATIONS\n      switch (this.token) {\n        case \"=\": {\n          if (isConst) this.error(\"VARIABLE\");\n          if (this.next().token == \"&\") {\n            return this.read_assignref(result, expr);\n          }\n          return result(\"assign\", expr, this.read_expr(), \"=\");\n        }\n\n        // operations :\n        case this.tok.T_PLUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"+=\");\n\n        case this.tok.T_MINUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"-=\");\n\n        case this.tok.T_MUL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"*=\");\n\n        case this.tok.T_POW_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"**=\");\n\n        case this.tok.T_DIV_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"/=\");\n\n        case this.tok.T_CONCAT_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \".=\");\n\n        case this.tok.T_MOD_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"%=\");\n\n        case this.tok.T_AND_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"&=\");\n\n        case this.tok.T_OR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"|=\");\n\n        case this.tok.T_XOR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"^=\");\n\n        case this.tok.T_SL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"<<=\");\n\n        case this.tok.T_SR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \">>=\");\n\n        case this.tok.T_COALESCE_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"??=\");\n\n        case this.tok.T_INC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"+\", expr);\n        case this.tok.T_DEC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"-\", expr);\n        default:\n          // see #193\n          result.destroy(expr);\n      }\n    } else if (this.is(\"SCALAR\")) {\n      result = this.node();\n      expr = this.read_scalar();\n      if (expr.kind === \"array\" && expr.shortForm && this.token === \"=\") {\n        // list assign\n        const list = this.convertToList(expr);\n        if (expr.loc) list.loc = expr.loc;\n        const right = this.next().read_expr();\n        return result(\"assign\", list, right, \"=\");\n      } else {\n        // see #189 - swap docs on nodes\n        result.destroy(expr);\n      }\n      // classic array\n      return this.handleDereferencable(expr);\n    } else {\n      this.error(\"EXPR\");\n      this.next();\n    }\n\n    // returns variable | scalar\n    return expr;\n  },\n\n  /**\n   * Recursively convert nested array to nested list.\n   */\n  convertToList: function (array) {\n    const convertedItems = array.items.map((entry) => {\n      if (\n        entry.value &&\n        entry.value.kind === \"array\" &&\n        entry.value.shortForm\n      ) {\n        entry.value = this.convertToList(entry.value);\n      }\n      return entry;\n    });\n    const node = this.node(\"list\")(convertedItems, true);\n    if (array.loc) node.loc = array.loc;\n    if (array.leadingComments) node.leadingComments = array.leadingComments;\n    if (array.trailingComments) node.trailingComments = array.trailingComments;\n    return node;\n  },\n\n  /**\n   * Reads assignment\n   * @param {*} left\n   */\n  read_assignref: function (result, left) {\n    this.next();\n    let right;\n    if (this.token === this.tok.T_NEW) {\n      if (this.version >= 700) {\n        this.error();\n      }\n      right = this.read_new_expr();\n    } else {\n      right = this.read_variable(false, false);\n    }\n\n    return result(\"assignref\", left, right);\n  },\n\n  /**\n   *\n   * inline_function:\n   * \t\tfunction returns_ref backup_doc_comment '(' parameter_list ')' lexical_vars return_type\n   * \t\tbackup_fn_flags '{' inner_statement_list '}' backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_CLOSURE, $2 | $13, $1, $3,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0),\n   * \t\t\t\t  $5, $7, $11, $8); CG(extra_fn_flags) = $9; }\n   * \t|\tfn returns_ref '(' parameter_list ')' return_type backup_doc_comment T_DOUBLE_ARROW backup_fn_flags backup_lex_pos expr backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_ARROW_FUNC, $2 | $12, $1, $7,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0), $4, NULL,\n   * \t\t\t\t  zend_ast_create(ZEND_AST_RETURN, $11), $6);\n   * \t\t\t\t  ((zend_ast_decl *) $$)->lex_pos = $10;\n   * \t\t\t\t  CG(extra_fn_flags) = $9; }   *\n   */\n  read_inline_function: function (flags) {\n    if (this.token === this.tok.T_FUNCTION) {\n      return this.read_function(true, flags);\n    }\n    // introduced in PHP 7.4\n    if (!this.version >= 704) {\n      this.raiseError(\"Arrow Functions are not allowed\");\n    }\n    // as an arrowfunc\n    const node = this.node(\"arrowfunc\");\n    // eat T_FN\n    if (this.expect(this.tok.T_FN)) this.next();\n    // check the &\n    const isRef = this.is_reference();\n    // ...\n    if (this.expect(\"(\")) this.next();\n    const params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n    let nullable = false;\n    let returnType = null;\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n      returnType = this.read_type();\n    }\n    if (this.expect(this.tok.T_DOUBLE_ARROW)) this.next();\n    const body = this.read_expr();\n    return node(\n      params,\n      isRef,\n      body,\n      returnType,\n      nullable,\n      flags ? true : false\n    );\n  },\n\n  /**\n   * ```ebnf\n   *    new_expr ::= T_NEW (namespace_name function_argument_list) | (T_CLASS ... class declaration)\n   * ```\n   * https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L850\n   */\n  read_new_expr: function () {\n    const result = this.node(\"new\");\n    this.expect(this.tok.T_NEW) && this.next();\n    let args = [];\n    if (this.token === this.tok.T_CLASS) {\n      const what = this.node(\"class\");\n      // Annonymous class declaration\n      if (this.next().token === \"(\") {\n        args = this.read_argument_list();\n      }\n      const propExtends = this.read_extends_from();\n      const propImplements = this.read_implements_list();\n      let body = null;\n      if (this.expect(\"{\")) {\n        body = this.next().read_class_body();\n      }\n      return result(\n        what(null, propExtends, propImplements, body, [0, 0, 0]),\n        args\n      );\n    }\n    // Already existing class\n    const name = this.read_new_class_name();\n    if (this.token === \"(\") {\n      args = this.read_argument_list();\n    }\n    return result(name, args);\n  },\n  /**\n   * Reads a class name\n   * ```ebnf\n   * read_new_class_name ::= namespace_name | variable\n   * ```\n   */\n  read_new_class_name: function () {\n    if (\n      this.token === this.tok.T_NS_SEPARATOR ||\n      this.token === this.tok.T_STRING ||\n      this.token === this.tok.T_NAMESPACE\n    ) {\n      let result = this.read_namespace_name(true);\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        result = this.read_static_getter(result);\n      }\n      return result;\n    } else if (this.is(\"VARIABLE\")) {\n      return this.read_variable(true, false);\n    } else {\n      this.expect([this.tok.T_STRING, \"VARIABLE\"]);\n    }\n  },\n  handleDereferencable: function (expr) {\n    while (this.token !== this.EOF) {\n      if (\n        this.token === this.tok.T_OBJECT_OPERATOR ||\n        this.token === this.tok.T_DOUBLE_COLON\n      ) {\n        expr = this.recursive_variable_chain_scan(expr, false, false, true);\n      } else if (this.token === this.tok.T_CURLY_OPEN || this.token === \"[\") {\n        expr = this.read_dereferencable(expr);\n      } else if (this.token === \"(\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1118\n        expr = this.node(\"call\")(expr, this.read_argument_list());\n      } else {\n        return expr;\n      }\n    }\n    return expr;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * checks if current token is a reference keyword\n   */\n  is_reference: function () {\n    if (this.token == \"&\") {\n      this.next();\n      return true;\n    }\n    return false;\n  },\n  /**\n   * checks if current token is a variadic keyword\n   */\n  is_variadic: function () {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      this.next();\n      return true;\n    }\n    return false;\n  },\n  /**\n   * reading a function\n   * ```ebnf\n   * function ::= function_declaration code_block\n   * ```\n   */\n  read_function: function (closure, flag) {\n    const result = this.read_function_declaration(\n      closure ? 1 : flag ? 2 : 0,\n      flag && flag[1] === 1\n    );\n    if (flag && flag[2] == 1) {\n      // abstract function :\n      result.parseFlags(flag);\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\"{\")) {\n        result.body = this.read_code_block(false);\n        if (result.loc && result.body.loc) {\n          result.loc.end = result.body.loc.end;\n        }\n      }\n      if (!closure && flag) {\n        result.parseFlags(flag);\n      }\n    }\n    return result;\n  },\n  /**\n   * reads a function declaration (without his body)\n   * ```ebnf\n   * function_declaration ::= T_FUNCTION '&'?  T_STRING '(' parameter_list ')'\n   * ```\n   */\n  read_function_declaration: function (type, isStatic) {\n    let nodeName = \"function\";\n    if (type === 1) {\n      nodeName = \"closure\";\n    } else if (type === 2) {\n      nodeName = \"method\";\n    }\n    const result = this.node(nodeName);\n\n    if (this.expect(this.tok.T_FUNCTION)) {\n      this.next();\n    }\n    const isRef = this.is_reference();\n    let name = false,\n      use = [],\n      returnType = null,\n      nullable = false;\n    if (type !== 1) {\n      const nameNode = this.node(\"identifier\");\n      if (type === 2) {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING || this.is(\"IDENTIFIER\")) {\n            name = this.text();\n            this.next();\n          } else if (this.version < 704) {\n            this.error(\"IDENTIFIER\");\n          }\n        } else if (this.token === this.tok.T_STRING) {\n          name = this.text();\n          this.next();\n        } else {\n          this.error(\"IDENTIFIER\");\n        }\n      } else {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING) {\n            name = this.text();\n            this.next();\n          } else if (this.version >= 704) {\n            if (!this.expect(\"(\")) {\n              this.next();\n            }\n          } else {\n            this.error(this.tok.T_STRING);\n            this.next();\n          }\n        } else {\n          if (this.expect(this.tok.T_STRING)) {\n            name = this.text();\n          }\n          this.next();\n        }\n      }\n      name = nameNode(name);\n    }\n    if (this.expect(\"(\")) this.next();\n    const params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n    if (type === 1) {\n      use = this.read_lexical_vars();\n    }\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n      returnType = this.read_type();\n    }\n    if (type === 1) {\n      // closure\n      return result(params, isRef, use, returnType, nullable, isStatic);\n    }\n    return result(name, params, isRef, returnType, nullable);\n  },\n\n  read_lexical_vars: function () {\n    let result = [];\n\n    if (this.token === this.tok.T_USE) {\n      this.next();\n      this.expect(\"(\") && this.next();\n      result = this.read_lexical_var_list();\n      this.expect(\")\") && this.next();\n    }\n\n    return result;\n  },\n\n  read_lexical_var_list: function () {\n    return this.read_list(this.read_lexical_var, \",\");\n  },\n\n  /**\n   * ```ebnf\n   * lexical_var ::= '&'? T_VARIABLE\n   * ```\n   */\n  read_lexical_var: function () {\n    if (this.token === \"&\") {\n      return this.read_byref(this.read_lexical_var.bind(this));\n    }\n    const result = this.node(\"variable\");\n    this.expect(this.tok.T_VARIABLE);\n    const name = this.text().substring(1);\n    this.next();\n    return result(name, false);\n  },\n  /**\n   * reads a list of parameters\n   * ```ebnf\n   *  parameter_list ::= (parameter ',')* parameter?\n   * ```\n   */\n  read_parameter_list: function () {\n    const result = [];\n    if (this.token != \")\") {\n      while (this.token != this.EOF) {\n        result.push(this.read_parameter());\n        if (this.token == \",\") {\n          this.next();\n        } else if (this.token == \")\") {\n          break;\n        } else {\n          this.error([\",\", \")\"]);\n          break;\n        }\n      }\n    }\n    return result;\n  },\n  /**\n   * ```ebnf\n   *  parameter ::= type? '&'? T_ELLIPSIS? T_VARIABLE ('=' expr)?\n   * ```\n   * @see https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L640\n   */\n  read_parameter: function () {\n    const node = this.node(\"parameter\");\n    let parameterName = null;\n    let value = null;\n    let type = null;\n    let nullable = false;\n    if (this.token === \"?\") {\n      this.next();\n      nullable = true;\n    }\n    type = this.read_type();\n    if (nullable && !type) {\n      this.raiseError(\n        \"Expecting a type definition combined with nullable operator\"\n      );\n    }\n    const isRef = this.is_reference();\n    const isVariadic = this.is_variadic();\n    if (this.expect(this.tok.T_VARIABLE)) {\n      parameterName = this.node(\"identifier\");\n      const name = this.text().substring(1);\n      this.next();\n      parameterName = parameterName(name);\n    }\n    if (this.token == \"=\") {\n      value = this.next().read_expr();\n    }\n    return node(parameterName, type, value, isRef, isVariadic, nullable);\n  },\n  /**\n   * Reads a list of arguments\n   * ```ebnf\n   *  function_argument_list ::= '(' (argument_list (',' argument_list)*)? ')'\n   * ```\n   */\n  read_argument_list: function () {\n    let result = [];\n    this.expect(\"(\") && this.next();\n    if (this.token !== \")\") {\n      result = this.read_non_empty_argument_list();\n    }\n    this.expect(\")\") && this.next();\n    return result;\n  },\n  /**\n   * Reads non empty argument list\n   */\n  read_non_empty_argument_list: function () {\n    let wasVariadic = false;\n\n    return this.read_function_list(\n      function () {\n        const argument = this.read_argument();\n        if (argument) {\n          if (wasVariadic) {\n            this.raiseError(\"Unexpected argument after a variadic argument\");\n          }\n          if (argument.kind === \"variadic\") {\n            wasVariadic = true;\n          }\n        }\n        return argument;\n      }.bind(this),\n      \",\"\n    );\n  },\n  /**\n   * ```ebnf\n   *    argument_list ::= T_ELLIPSIS? expr\n   * ```\n   */\n  read_argument: function () {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      return this.node(\"variadic\")(this.next().read_expr());\n    }\n    return this.read_expr();\n  },\n  /**\n   * read type hinting\n   * ```ebnf\n   *  type ::= T_ARRAY | T_CALLABLE | namespace_name\n   * ```\n   */\n  read_type: function () {\n    const result = this.node();\n    if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {\n      const type = this.text();\n      this.next();\n      return result(\"typereference\", type.toLowerCase(), type);\n    } else if (this.token === this.tok.T_STRING) {\n      const type = this.text();\n      const backup = [this.token, this.lexer.getState()];\n      this.next();\n      if (\n        this.token !== this.tok.T_NS_SEPARATOR &&\n        this.ast.typereference.types.indexOf(type.toLowerCase()) > -1\n      ) {\n        return result(\"typereference\", type.toLowerCase(), type);\n      } else {\n        // rollback a classic namespace\n        this.lexer.tokens.push(backup);\n        this.next();\n        // fix : destroy not consumed node (release comments)\n        result.destroy();\n        return this.read_namespace_name();\n      }\n    } else if (\n      this.token === this.tok.T_NAMESPACE ||\n      this.token === this.tok.T_NS_SEPARATOR\n    ) {\n      // fix : destroy not consumed node (release comments)\n      result.destroy();\n      return this.read_namespace_name();\n    }\n    // fix : destroy not consumed node (release comments)\n    result.destroy();\n    return null;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads an IF statement\n   *\n   * ```ebnf\n   *  if ::= T_IF '(' expr ')' ':' ...\n   * ```\n   */\n  read_if: function () {\n    const result = this.node(\"if\");\n    const test = this.next().read_if_expr();\n    let body = null;\n    let alternate = null;\n    let shortForm = false;\n\n    if (this.token === \":\") {\n      shortForm = true;\n      this.next();\n      body = this.node(\"block\");\n      const items = [];\n      while (this.token !== this.EOF && this.token !== this.tok.T_ENDIF) {\n        if (this.token === this.tok.T_ELSEIF) {\n          alternate = this.read_elseif_short();\n          break;\n        } else if (this.token === this.tok.T_ELSE) {\n          alternate = this.read_else_short();\n          break;\n        }\n        items.push(this.read_inner_statement());\n      }\n      body = body(null, items);\n      this.expect(this.tok.T_ENDIF) && this.next();\n      this.expectEndOfStatement();\n    } else {\n      body = this.read_statement();\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_if();\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.next().read_statement();\n      }\n    }\n    return result(test, body, alternate, shortForm);\n  },\n  /**\n   * reads an if expression : '(' expr ')'\n   */\n  read_if_expr: function () {\n    this.expect(\"(\") && this.next();\n    const result = this.read_expr();\n    this.expect(\")\") && this.next();\n    return result;\n  },\n  /**\n   * reads an elseif (expr): statements\n   */\n  read_elseif_short: function () {\n    let alternate = null;\n    const result = this.node(\"if\");\n    const test = this.next().read_if_expr();\n    if (this.expect(\":\")) this.next();\n    const body = this.node(\"block\");\n    const items = [];\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_elseif_short();\n        break;\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.read_else_short();\n        break;\n      }\n      items.push(this.read_inner_statement());\n    }\n    return result(test, body(null, items), alternate, true);\n  },\n  /**\n   *\n   */\n  read_else_short: function () {\n    if (this.next().expect(\":\")) this.next();\n    const body = this.node(\"block\");\n    const items = [];\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      items.push(this.read_inner_statement());\n    }\n    return body(null, items);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a while statement\n   * ```ebnf\n   * while ::= T_WHILE (statement | ':' inner_statement_list T_ENDWHILE ';')\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L587\n   * @return {While}\n   */\n  read_while: function () {\n    const result = this.node(\"while\");\n    this.expect(this.tok.T_WHILE) && this.next();\n    let test = null;\n    let body = null;\n    let shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    test = this.read_expr();\n    if (this.expect(\")\")) this.next();\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDWHILE);\n    } else {\n      body = this.read_statement();\n    }\n    return result(test, body, shortForm);\n  },\n  /**\n   * Reads a do / while loop\n   * ```ebnf\n   * do ::= T_DO statement T_WHILE '(' expr ')' ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L423\n   * @return {Do}\n   */\n  read_do: function () {\n    const result = this.node(\"do\");\n    this.expect(this.tok.T_DO) && this.next();\n    let test = null;\n    let body = null;\n    body = this.read_statement();\n    if (this.expect(this.tok.T_WHILE)) {\n      if (this.next().expect(\"(\")) this.next();\n      test = this.read_expr();\n      if (this.expect(\")\")) this.next();\n      if (this.expect(\";\")) this.next();\n    }\n    return result(test, body);\n  },\n  /**\n   * Read a for incremental loop\n   * ```ebnf\n   * for ::= T_FOR '(' for_exprs ';' for_exprs ';' for_exprs ')' for_statement\n   * for_statement ::= statement | ':' inner_statement_list T_ENDFOR ';'\n   * for_exprs ::= expr? (',' expr)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L425\n   * @return {For}\n   */\n  read_for: function () {\n    const result = this.node(\"for\");\n    this.expect(this.tok.T_FOR) && this.next();\n    let init = [];\n    let test = [];\n    let increment = [];\n    let body = null;\n    let shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    if (this.token !== \";\") {\n      init = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n    if (this.token !== \";\") {\n      test = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n    if (this.token !== \")\") {\n      increment = this.read_list(this.read_expr, \",\");\n      if (this.expect(\")\")) this.next();\n    } else {\n      this.next();\n    }\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOR);\n    } else {\n      body = this.read_statement();\n    }\n    return result(init, test, increment, body, shortForm);\n  },\n  /**\n   * Reads a foreach loop\n   * ```ebnf\n   * foreach ::= '(' expr T_AS foreach_variable (T_DOUBLE_ARROW foreach_variable)? ')' statement\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L438\n   * @return {Foreach}\n   */\n  read_foreach: function () {\n    const result = this.node(\"foreach\");\n    this.expect(this.tok.T_FOREACH) && this.next();\n    let source = null;\n    let key = null;\n    let value = null;\n    let body = null;\n    let shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    source = this.read_expr();\n    if (this.expect(this.tok.T_AS)) {\n      this.next();\n      value = this.read_foreach_variable();\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        key = value;\n        value = this.next().read_foreach_variable();\n      }\n    }\n\n    // grammatically correct but not supported by PHP\n    if (key && key.kind === \"list\") {\n      this.raiseError(\"Fatal Error : Cannot use list as key element\");\n    }\n\n    if (this.expect(\")\")) this.next();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOREACH);\n    } else {\n      body = this.read_statement();\n    }\n    return result(source, key, value, body, shortForm);\n  },\n  /**\n   * Reads a foreach variable statement\n   * ```ebnf\n   * foreach_variable =\n   *    variable |\n   *    '&' variable |\n   *    T_LIST '(' assignment_list ')' |\n   *    '[' assignment_list ']'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L544\n   * @return {Expression}\n   */\n  read_foreach_variable: function () {\n    if (this.token === this.tok.T_LIST || this.token === \"[\") {\n      const isShort = this.token === \"[\";\n      const result = this.node(\"list\");\n      this.next();\n      if (!isShort && this.expect(\"(\")) this.next();\n      const assignList = this.read_array_pair_list(isShort);\n      if (this.expect(isShort ? \"]\" : \")\")) this.next();\n      return result(assignList, isShort);\n    } else {\n      return this.read_variable(false, false);\n    }\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   * start ::= (namespace | top_statement)*\n   * ```\n   */\n  read_start: function () {\n    if (this.token == this.tok.T_NAMESPACE) {\n      return this.read_namespace();\n    } else {\n      return this.read_top_statement();\n    }\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a namespace declaration block\n   * ```ebnf\n   * namespace ::= T_NAMESPACE namespace_name? '{'\n   *    top_statements\n   * '}'\n   * | T_NAMESPACE namespace_name ';' top_statements\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.php\n   * @return {Namespace}\n   */\n  read_namespace: function () {\n    const result = this.node(\"namespace\");\n    let body;\n    this.expect(this.tok.T_NAMESPACE) && this.next();\n    let name;\n\n    if (this.token == \"{\") {\n      name = {\n        name: [\"\"],\n      };\n    } else {\n      name = this.read_namespace_name();\n    }\n    this.currentNamespace = name;\n\n    if (this.token == \";\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(this.EOF);\n      return result(name.name, body, false);\n    } else if (this.token == \"{\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(\"}\") && this.next();\n      if (\n        body.length === 0 &&\n        this.extractDoc &&\n        this._docs.length > this._docIndex\n      ) {\n        body.push(this.node(\"noop\")());\n      }\n      return result(name.name, body, true);\n    } else if (this.token === \"(\") {\n      // @fixme after merging #478\n      name.resolution = this.ast.reference.RELATIVE_NAME;\n      name.name = name.name.substring(1);\n      result.destroy();\n      return this.node(\"call\")(name, this.read_argument_list());\n    } else {\n      this.error([\"{\", \";\"]);\n      // graceful mode :\n      this.currentNamespace = name;\n      body = this.read_top_statements();\n      this.expect(this.EOF);\n      return result(name, body, false);\n    }\n  },\n  /**\n   * Reads a namespace name\n   * ```ebnf\n   *  namespace_name ::= T_NS_SEPARATOR? (T_STRING T_NS_SEPARATOR)* T_STRING\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.rules.php\n   * @return {Reference}\n   */\n  read_namespace_name: function (resolveReference) {\n    const result = this.node();\n    let relative = false;\n    if (this.token === this.tok.T_NAMESPACE) {\n      this.next().expect(this.tok.T_NS_SEPARATOR) && this.next();\n      relative = true;\n    }\n    const names = this.read_list(\n      this.tok.T_STRING,\n      this.tok.T_NS_SEPARATOR,\n      true\n    );\n    if (\n      !relative &&\n      names.length === 1 &&\n      (resolveReference || this.token !== \"(\")\n    ) {\n      if (names[0].toLowerCase() === \"parent\") {\n        return result(\"parentreference\", names[0]);\n      } else if (names[0].toLowerCase() === \"self\") {\n        return result(\"selfreference\", names[0]);\n      }\n    }\n    return result(\"name\", names, relative);\n  },\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_statement ::= T_USE\n   *   use_type? use_declarations |\n   *   use_type use_statement '{' use_declarations '}' |\n   *   use_statement '{' use_declarations(=>typed) '}'\n   * ';'\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.importing.php\n   * @return {UseGroup}\n   */\n  read_use_statement: function () {\n    let result = this.node(\"usegroup\");\n    let items = [];\n    let name = null;\n    this.expect(this.tok.T_USE) && this.next();\n    const type = this.read_use_type();\n    items.push(this.read_use_declaration(false));\n    if (this.token === \",\") {\n      items = items.concat(this.next().read_use_declarations(false));\n    } else if (this.token === \"{\") {\n      name = items[0].name;\n      items = this.next().read_use_declarations(type === null);\n      this.expect(\"}\") && this.next();\n    }\n    result = result(name, type, items);\n    this.expect(\";\") && this.next();\n    return result;\n  },\n  /**\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1045\n   */\n  read_class_name_reference: function () {\n    // resolved as the same\n    return this.read_variable(true, false);\n  },\n  /**\n   * Reads a use declaration\n   * ```ebnf\n   * use_declaration ::= use_type? namespace_name use_alias\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem}\n   */\n  read_use_declaration: function (typed) {\n    const result = this.node(\"useitem\");\n    let type = null;\n    if (typed) type = this.read_use_type();\n    const name = this.read_namespace_name();\n    const alias = this.read_use_alias();\n    return result(name.name, alias, type);\n  },\n  /**\n   * Reads a list of use declarations\n   * ```ebnf\n   * use_declarations ::= use_declaration (',' use_declaration)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem[]}\n   */\n  read_use_declarations: function (typed) {\n    const result = [this.read_use_declaration(typed)];\n    while (this.token === \",\") {\n      this.next();\n      if (typed) {\n        if (\n          this.token !== this.tok.T_FUNCTION &&\n          this.token !== this.tok.T_CONST &&\n          this.token !== this.tok.T_STRING\n        ) {\n          break;\n        }\n      } else if (\n        this.token !== this.tok.T_STRING &&\n        this.token !== this.tok.T_NS_SEPARATOR\n      ) {\n        break;\n      }\n      result.push(this.read_use_declaration(typed));\n    }\n    return result;\n  },\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_alias ::= (T_AS T_STRING)?\n   * ```\n   * @return {String|null}\n   */\n  read_use_alias: function () {\n    let result = null;\n    if (this.token === this.tok.T_AS) {\n      if (this.next().expect(this.tok.T_STRING)) {\n        const aliasName = this.node(\"identifier\");\n        const name = this.text();\n        this.next();\n        result = aliasName(name);\n      }\n    }\n    return result;\n  },\n  /**\n   * Reads the namespace type declaration\n   * ```ebnf\n   * use_type ::= (T_FUNCTION | T_CONST)?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L335\n   * @return {String|null} Possible values : function, const\n   */\n  read_use_type: function () {\n    if (this.token === this.tok.T_FUNCTION) {\n      this.next();\n      return this.ast.useitem.TYPE_FUNCTION;\n    } else if (this.token === this.tok.T_CONST) {\n      this.next();\n      return this.ast.useitem.TYPE_CONST;\n    }\n    return null;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nconst specialChar = {\n  \"\\\\\": \"\\\\\",\n  $: \"$\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\\t\",\n  f: String.fromCharCode(12),\n  v: String.fromCharCode(11),\n  e: String.fromCharCode(27),\n};\n\nmodule.exports = {\n  /**\n   * Unescape special chars\n   */\n  resolve_special_chars: function (text, doubleQuote) {\n    if (!doubleQuote) {\n      // single quote fix\n      return text.replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\'/g, \"'\");\n    }\n    return text\n      .replace(/\\\\\"/, '\"')\n      .replace(\n        /\\\\([\\\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g,\n        ($match, p1, p2) => {\n          if (specialChar[p1]) {\n            return specialChar[p1];\n          } else if (\"x\" === p1[0] || \"X\" === p1[0]) {\n            return String.fromCodePoint(parseInt(p1.substr(1), 16));\n          } else if (\"u\" === p1[0]) {\n            return String.fromCodePoint(parseInt(p2, 16));\n          } else {\n            return String.fromCodePoint(parseInt(p1, 8));\n          }\n        }\n      );\n  },\n\n  /**\n   * Remove all leading spaces each line for heredoc text if there is a indentation\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  remove_heredoc_leading_whitespace_chars: function (\n    text,\n    indentation,\n    indentation_uses_spaces,\n    first_encaps_node\n  ) {\n    if (indentation === 0) {\n      return text;\n    }\n\n    this.check_heredoc_indentation_level(\n      text,\n      indentation,\n      indentation_uses_spaces,\n      first_encaps_node\n    );\n\n    const matchedChar = indentation_uses_spaces ? \" \" : \"\\t\";\n    const removementRegExp = new RegExp(\n      `\\\\n${matchedChar}{${indentation}}`,\n      \"g\"\n    );\n    const removementFirstEncapsNodeRegExp = new RegExp(\n      `^${matchedChar}{${indentation}}`\n    );\n\n    // Rough replace, need more check\n    if (first_encaps_node) {\n      // Remove text leading whitespace\n      text = text.replace(removementFirstEncapsNodeRegExp, \"\");\n    }\n\n    // Remove leading whitespace after \\n\n    return text.replace(removementRegExp, \"\\n\");\n  },\n\n  /**\n   * Check indentation level of heredoc in text, if mismatch, raiseError\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  check_heredoc_indentation_level: function (\n    text,\n    indentation,\n    indentation_uses_spaces,\n    first_encaps_node\n  ) {\n    const textSize = text.length;\n    let offset = 0;\n    let leadingWhitespaceCharCount = 0;\n    /**\n     * @var inCoutingState {boolean} reset to true after a new line\n     */\n    let inCoutingState = true;\n    const chToCheck = indentation_uses_spaces ? \" \" : \"\\t\";\n    let inCheckState = false;\n    if (!first_encaps_node) {\n      // start from first \\n\n      offset = text.indexOf(\"\\n\");\n      // if no \\n, just return\n      if (offset === -1) {\n        return;\n      }\n      offset++;\n    }\n    while (offset < textSize) {\n      if (inCoutingState) {\n        if (text[offset] === chToCheck) {\n          leadingWhitespaceCharCount++;\n        } else {\n          inCheckState = true;\n        }\n      } else {\n        inCoutingState = false;\n      }\n\n      if (\n        text[offset] !== \"\\n\" &&\n        inCheckState &&\n        leadingWhitespaceCharCount < indentation\n      ) {\n        this.raiseError(\n          `Invalid body indentation level (expecting an indentation at least ${indentation})`\n        );\n      } else {\n        inCheckState = false;\n      }\n\n      if (text[offset] === \"\\n\") {\n        // Reset counting state\n        inCoutingState = true;\n        leadingWhitespaceCharCount = 0;\n      }\n      offset++;\n    }\n  },\n\n  /**\n   * Reads dereferencable scalar\n   */\n  read_dereferencable_scalar: function () {\n    let result = null;\n\n    switch (this.token) {\n      case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        {\n          let value = this.node(\"string\");\n          const text = this.text();\n          let offset = 0;\n          if (text[0] === \"b\" || text[0] === \"B\") {\n            offset = 1;\n          }\n          const isDoubleQuote = text[offset] === '\"';\n          this.next();\n          const textValue = this.resolve_special_chars(\n            text.substring(offset + 1, text.length - 1),\n            isDoubleQuote\n          );\n          value = value(\n            isDoubleQuote,\n            textValue,\n            offset === 1, // unicode flag\n            text\n          );\n          if (this.token === this.tok.T_DOUBLE_COLON) {\n            // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1151\n            result = this.read_static_getter(value);\n          } else {\n            // dirrect string\n            result = value;\n          }\n        }\n        break;\n      case this.tok.T_ARRAY: // array parser\n        result = this.read_array();\n        break;\n      case \"[\": // short array format\n        result = this.read_array();\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  scalar ::= T_MAGIC_CONST\n   *       | T_LNUMBER | T_DNUMBER\n   *       | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE? T_END_HEREDOC\n   *       | '\"' encaps_list '\"'\n   *       | T_START_HEREDOC encaps_list T_END_HEREDOC\n   *       | namespace_name (T_DOUBLE_COLON T_STRING)?\n   * ```\n   */\n  read_scalar: function () {\n    if (this.is(\"T_MAGIC_CONST\")) {\n      return this.get_magic_constant();\n    } else {\n      let value, node;\n      switch (this.token) {\n        // NUMERIC\n        case this.tok.T_LNUMBER: // long\n        case this.tok.T_DNUMBER: {\n          // double\n          const result = this.node(\"number\");\n          value = this.text();\n          this.next();\n          return result(value, null);\n        }\n        case this.tok.T_START_HEREDOC:\n          if (this.lexer.curCondition === \"ST_NOWDOC\") {\n            const start = this.lexer.yylloc.first_offset;\n            node = this.node(\"nowdoc\");\n            value = this.next().text();\n            // strip the last line return char\n            if (this.lexer.heredoc_label.indentation > 0) {\n              value = value.substring(\n                0,\n                value.length - this.lexer.heredoc_label.indentation\n              );\n            }\n            const lastCh = value[value.length - 1];\n            if (lastCh === \"\\n\") {\n              if (value[value.length - 2] === \"\\r\") {\n                // windows style\n                value = value.substring(0, value.length - 2);\n              } else {\n                // linux style\n                value = value.substring(0, value.length - 1);\n              }\n            } else if (lastCh === \"\\r\") {\n              // mac style\n              value = value.substring(0, value.length - 1);\n            }\n            this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next();\n            this.expect(this.tok.T_END_HEREDOC) && this.next();\n            const raw = this.lexer._input.substring(\n              start,\n              this.lexer.yylloc.first_offset\n            );\n            node = node(\n              this.remove_heredoc_leading_whitespace_chars(\n                value,\n                this.lexer.heredoc_label.indentation,\n                this.lexer.heredoc_label.indentation_uses_spaces,\n                this.lexer.heredoc_label.first_encaps_node\n              ),\n              raw,\n              this.lexer.heredoc_label.label\n            );\n            return node;\n          } else {\n            return this.read_encapsed_string(this.tok.T_END_HEREDOC);\n          }\n\n        case '\"':\n          return this.read_encapsed_string('\"');\n\n        case 'b\"':\n        case 'B\"': {\n          return this.read_encapsed_string('\"', true);\n        }\n\n        // TEXTS\n        case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        case this.tok.T_ARRAY: // array parser\n        case \"[\": // short array format\n          return this.read_dereferencable_scalar();\n        default: {\n          const err = this.error(\"SCALAR\");\n          // graceful mode : ignore token & return error node\n          this.next();\n          return err;\n        }\n      }\n    }\n  },\n  /**\n   * Handles the dereferencing\n   */\n  read_dereferencable: function (expr) {\n    let result, offset;\n    const node = this.node(\"offsetlookup\");\n    if (this.token === \"[\") {\n      offset = this.next().read_expr();\n      if (this.expect(\"]\")) this.next();\n      result = node(expr, offset);\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      offset = this.read_encapsed_string_item(false);\n      result = node(expr, offset);\n    }\n    return result;\n  },\n  /**\n   * Reads and extracts an encapsed item\n   * ```ebnf\n   * encapsed_string_item ::= T_ENCAPSED_AND_WHITESPACE\n   *  | T_DOLLAR_OPEN_CURLY_BRACES expr '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}'\n   *  | T_CURLY_OPEN variable '}'\n   *  | variable\n   *  | variable '[' expr ']'\n   *  | variable T_OBJECT_OPERATOR T_STRING\n   * ```\n   * @return {String|Variable|Expr|Lookup}\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1219\n   */\n  read_encapsed_string_item: function (isDoubleQuote) {\n    const encapsedPart = this.node(\"encapsedpart\");\n    let syntax = null;\n    let curly = false;\n    let result = this.node(),\n      offset,\n      node,\n      name;\n\n    // plain text\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1222\n    if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {\n      const text = this.text();\n      this.next();\n\n      // if this.lexer.heredoc_label.first_encaps_node -> remove first indents\n      result = result(\n        \"string\",\n        false,\n        this.version >= 703 && !this.lexer.heredoc_label.finished\n          ? this.remove_heredoc_leading_whitespace_chars(\n              this.resolve_special_chars(text, isDoubleQuote),\n              this.lexer.heredoc_label.indentation,\n              this.lexer.heredoc_label.indentation_uses_spaces,\n              this.lexer.heredoc_label.first_encaps_node\n            )\n          : text,\n        false,\n        text\n      );\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      syntax = \"simple\";\n      curly = true;\n      // dynamic variable name\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1239\n      name = null;\n      if (this.next().token === this.tok.T_STRING_VARNAME) {\n        name = this.node(\"variable\");\n        const varName = this.text();\n        this.next();\n        // check if lookup an offset\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1243\n        if (this.token === \"[\") {\n          name = name(varName, false);\n          node = this.node(\"offsetlookup\");\n          offset = this.next().read_expr();\n          this.expect(\"]\") && this.next();\n          result = node(name, offset);\n        } else {\n          result = name(varName, false);\n        }\n      } else {\n        result = result(\"variable\", this.read_expr(), false);\n      }\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_CURLY_OPEN) {\n      // expression\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1246\n      syntax = \"complex\";\n      result.destroy();\n      result = this.next().read_variable(false, false);\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_VARIABLE) {\n      syntax = \"simple\";\n      // plain variable\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1231\n      result.destroy();\n      result = this.read_simple_variable();\n\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1233\n      if (this.token === \"[\") {\n        node = this.node(\"offsetlookup\");\n        offset = this.next().read_encaps_var_offset();\n        this.expect(\"]\") && this.next();\n        result = node(result, offset);\n      }\n\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1236\n      if (this.token === this.tok.T_OBJECT_OPERATOR) {\n        node = this.node(\"propertylookup\");\n        this.next().expect(this.tok.T_STRING);\n        const what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        result = node(result, what(name));\n      }\n\n      // error / fallback\n    } else {\n      this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);\n      const value = this.text();\n      this.next();\n      // consider it as string\n      result.destroy();\n      result = result(\"string\", false, value, false, value);\n    }\n\n    // reset first_encaps_node to false after access any node\n    this.lexer.heredoc_label.first_encaps_node = false;\n    return encapsedPart(result, syntax, curly);\n  },\n  /**\n   * Reads an encapsed string\n   */\n  read_encapsed_string: function (expect, isBinary = false) {\n    const labelStart = this.lexer.yylloc.first_offset;\n    let node = this.node(\"encapsed\");\n    this.next();\n    const start = this.lexer.yylloc.prev_offset - (isBinary ? 1 : 0);\n    const value = [];\n    let type = null;\n\n    if (expect === \"`\") {\n      type = this.ast.encapsed.TYPE_SHELL;\n    } else if (expect === '\"') {\n      type = this.ast.encapsed.TYPE_STRING;\n    } else {\n      type = this.ast.encapsed.TYPE_HEREDOC;\n    }\n\n    // reading encapsed parts\n    while (this.token !== expect && this.token !== this.EOF) {\n      value.push(this.read_encapsed_string_item(true));\n    }\n    if (\n      value.length > 0 &&\n      value[value.length - 1].kind === \"encapsedpart\" &&\n      value[value.length - 1].expression.kind === \"string\"\n    ) {\n      const node = value[value.length - 1].expression;\n      const lastCh = node.value[node.value.length - 1];\n      if (lastCh === \"\\n\") {\n        if (node.value[node.value.length - 2] === \"\\r\") {\n          // windows style\n          node.value = node.value.substring(0, node.value.length - 2);\n        } else {\n          // linux style\n          node.value = node.value.substring(0, node.value.length - 1);\n        }\n      } else if (lastCh === \"\\r\") {\n        // mac style\n        node.value = node.value.substring(0, node.value.length - 1);\n      }\n    }\n    this.expect(expect) && this.next();\n    const raw = this.lexer._input.substring(\n      type === \"heredoc\" ? labelStart : start - 1,\n      this.lexer.yylloc.first_offset\n    );\n    node = node(value, raw, type);\n\n    if (expect === this.tok.T_END_HEREDOC) {\n      node.label = this.lexer.heredoc_label.label;\n      this.lexer.heredoc_label.finished = true;\n    }\n    return node;\n  },\n  /**\n   * Constant token\n   */\n  get_magic_constant: function () {\n    const result = this.node(\"magic\");\n    const name = this.text();\n    this.next();\n    return result(name.toUpperCase(), name);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * reading a list of top statements (helper for top_statement*)\n   * ```ebnf\n   *  top_statements ::= top_statement*\n   * ```\n   */\n  read_top_statements: function () {\n    let result = [];\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      const statement = this.read_top_statement();\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n    return result;\n  },\n  /**\n   * reading a top statement\n   * ```ebnf\n   *  top_statement ::=\n   *       namespace | function | class\n   *       | interface | trait\n   *       | use_statements | const_list\n   *       | statement\n   * ```\n   */\n  read_top_statement: function () {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n      case this.tok.T_USE:\n        return this.read_use_statement();\n      case this.tok.T_CONST: {\n        const result = this.node(\"constantstatement\");\n        const items = this.next().read_const_list();\n        this.expectEndOfStatement();\n        return result(null, items);\n      }\n      case this.tok.T_NAMESPACE:\n        return this.read_namespace();\n      case this.tok.T_HALT_COMPILER: {\n        const result = this.node(\"halt\");\n        if (this.next().expect(\"(\")) this.next();\n        if (this.expect(\")\")) this.next();\n        this.expect(\";\");\n        this.lexer.done = true;\n        return result(this.lexer._input.substring(this.lexer.offset));\n      }\n      default:\n        return this.read_statement();\n    }\n  },\n  /**\n   * reads a list of simple inner statements (helper for inner_statement*)\n   * ```ebnf\n   *  inner_statements ::= inner_statement*\n   * ```\n   */\n  read_inner_statements: function () {\n    let result = [];\n    while (this.token != this.EOF && this.token !== \"}\") {\n      const statement = this.read_inner_statement();\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n    return result;\n  },\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)* ';'\n   * ```\n   */\n  read_const_list: function () {\n    return this.read_list(\n      function () {\n        this.expect(this.tok.T_STRING);\n        const result = this.node(\"constant\");\n        let constName = this.node(\"identifier\");\n        const name = this.text();\n        this.next();\n        constName = constName(name);\n        if (this.expect(\"=\")) {\n          return result(constName, this.next().read_expr());\n        } else {\n          // fallback\n          return result(constName, null);\n        }\n      },\n      \",\",\n      false\n    );\n  },\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   declare_list ::= IDENTIFIER '=' expr (',' IDENTIFIER '=' expr)*\n   * ```\n   * @retrurn {Array}\n   */\n  read_declare_list: function () {\n    const result = [];\n    while (this.token != this.EOF && this.token !== \")\") {\n      this.expect(this.tok.T_STRING);\n      const directive = this.node(\"declaredirective\");\n      let key = this.node(\"identifier\");\n      const name = this.text();\n      this.next();\n      key = key(name);\n      let value = null;\n      if (this.expect(\"=\")) {\n        value = this.next().read_expr();\n      }\n      result.push(directive(key, value));\n      if (this.token !== \",\") break;\n      this.next();\n    }\n    return result;\n  },\n  /**\n   * reads a simple inner statement\n   * ```ebnf\n   *  inner_statement ::= '{' inner_statements '}' | token\n   * ```\n   */\n  read_inner_statement: function () {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n      case this.tok.T_HALT_COMPILER: {\n        this.raiseError(\n          \"__HALT_COMPILER() can only be used from the outermost scope\"\n        );\n        // fallback : returns a node but does not stop the parsing\n        let node = this.node(\"halt\");\n        this.next().expect(\"(\") && this.next();\n        this.expect(\")\") && this.next();\n        node = node(this.lexer._input.substring(this.lexer.offset));\n        this.expect(\";\") && this.next();\n        return node;\n      }\n      default:\n        return this.read_statement();\n    }\n  },\n  /**\n   * Reads statements\n   */\n  read_statement: function () {\n    switch (this.token) {\n      case \"{\":\n        return this.read_code_block(false);\n\n      case this.tok.T_IF:\n        return this.read_if();\n\n      case this.tok.T_SWITCH:\n        return this.read_switch();\n\n      case this.tok.T_FOR:\n        return this.read_for();\n\n      case this.tok.T_FOREACH:\n        return this.read_foreach();\n\n      case this.tok.T_WHILE:\n        return this.read_while();\n\n      case this.tok.T_DO:\n        return this.read_do();\n\n      case this.tok.T_COMMENT:\n        return this.read_comment();\n\n      case this.tok.T_DOC_COMMENT:\n        return this.read_doc_comment();\n\n      case this.tok.T_RETURN: {\n        const result = this.node(\"return\");\n        this.next();\n        const expr = this.read_optional_expr(\";\");\n        this.expectEndOfStatement();\n        return result(expr);\n      }\n\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L429\n      case this.tok.T_BREAK:\n      case this.tok.T_CONTINUE: {\n        const result = this.node(\n          this.token === this.tok.T_CONTINUE ? \"continue\" : \"break\"\n        );\n        this.next();\n        const level = this.read_optional_expr(\";\");\n        this.expectEndOfStatement();\n        return result(level);\n      }\n\n      case this.tok.T_GLOBAL: {\n        const result = this.node(\"global\");\n        const items = this.next().read_list(this.read_simple_variable, \",\");\n        this.expectEndOfStatement();\n        return result(items);\n      }\n\n      case this.tok.T_STATIC: {\n        const current = [this.token, this.lexer.getState()];\n        const result = this.node();\n        if (this.next().token === this.tok.T_DOUBLE_COLON) {\n          // static keyword for a class\n          this.lexer.tokens.push(current);\n          const expr = this.next().read_expr();\n          this.expectEndOfStatement(expr);\n          return result(\"expressionstatement\", expr);\n        }\n        if (this.token === this.tok.T_FUNCTION) {\n          return this.read_function(true, [0, 1, 0]);\n        }\n        const items = this.read_variable_declarations();\n        this.expectEndOfStatement();\n        return result(\"static\", items);\n      }\n\n      case this.tok.T_ECHO: {\n        const result = this.node(\"echo\");\n        const text = this.text();\n        const shortForm = text === \"<?=\" || text === \"<%=\";\n        const expressions = this.next().read_function_list(this.read_expr, \",\");\n        this.expectEndOfStatement();\n        return result(expressions, shortForm);\n      }\n\n      case this.tok.T_INLINE_HTML: {\n        const value = this.text();\n        let prevChar =\n          this.lexer.yylloc.first_offset > 0\n            ? this.lexer._input[this.lexer.yylloc.first_offset - 1]\n            : null;\n        const fixFirstLine = prevChar === \"\\r\" || prevChar === \"\\n\";\n        // revert back the first stripped line\n        if (fixFirstLine) {\n          if (\n            prevChar === \"\\n\" &&\n            this.lexer.yylloc.first_offset > 1 &&\n            this.lexer._input[this.lexer.yylloc.first_offset - 2] === \"\\r\"\n          ) {\n            prevChar = \"\\r\\n\";\n          }\n        }\n        const result = this.node(\"inline\");\n        this.next();\n        return result(value, fixFirstLine ? prevChar + value : value);\n      }\n\n      case this.tok.T_UNSET: {\n        const result = this.node(\"unset\");\n        this.next().expect(\"(\") && this.next();\n        const variables = this.read_function_list(this.read_variable, \",\");\n        this.expect(\")\") && this.next();\n        this.expect(\";\") && this.next();\n        return result(variables);\n      }\n\n      case this.tok.T_DECLARE: {\n        const result = this.node(\"declare\");\n        const body = [];\n        let mode;\n        this.next().expect(\"(\") && this.next();\n        const directives = this.read_declare_list();\n        this.expect(\")\") && this.next();\n        if (this.token === \":\") {\n          this.next();\n          while (\n            this.token != this.EOF &&\n            this.token !== this.tok.T_ENDDECLARE\n          ) {\n            // @todo : check declare_statement from php / not valid\n            body.push(this.read_top_statement());\n          }\n          if (\n            body.length === 0 &&\n            this.extractDoc &&\n            this._docs.length > this._docIndex\n          ) {\n            body.push(this.node(\"noop\")());\n          }\n          this.expect(this.tok.T_ENDDECLARE) && this.next();\n          this.expectEndOfStatement();\n          mode = this.ast.declare.MODE_SHORT;\n        } else if (this.token === \"{\") {\n          this.next();\n          while (this.token != this.EOF && this.token !== \"}\") {\n            // @todo : check declare_statement from php / not valid\n            body.push(this.read_top_statement());\n          }\n          if (\n            body.length === 0 &&\n            this.extractDoc &&\n            this._docs.length > this._docIndex\n          ) {\n            body.push(this.node(\"noop\")());\n          }\n          this.expect(\"}\") && this.next();\n          mode = this.ast.declare.MODE_BLOCK;\n        } else {\n          this.expect(\";\") && this.next();\n          mode = this.ast.declare.MODE_NONE;\n        }\n        return result(directives, body, mode);\n      }\n\n      case this.tok.T_TRY:\n        return this.read_try();\n\n      case this.tok.T_THROW: {\n        const result = this.node(\"throw\");\n        const expr = this.next().read_expr();\n        this.expectEndOfStatement();\n        return result(expr);\n      }\n\n      // ignore this (extra ponctuation)\n      case \";\": {\n        this.next();\n        return null;\n      }\n\n      case this.tok.T_STRING: {\n        const result = this.node();\n        const current = [this.token, this.lexer.getState()];\n        const labelNameText = this.text();\n        let labelName = this.node(\"identifier\");\n        // AST : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L457\n        if (this.next().token === \":\") {\n          labelName = labelName(labelNameText);\n          this.next();\n          return result(\"label\", labelName);\n        } else {\n          labelName.destroy();\n        }\n\n        // default fallback expr / T_STRING '::' (etc...)\n        result.destroy();\n        this.lexer.tokens.push(current);\n        const statement = this.node(\"expressionstatement\");\n        const expr = this.next().read_expr();\n        this.expectEndOfStatement(expr);\n        return statement(expr);\n      }\n\n      case this.tok.T_GOTO: {\n        const result = this.node(\"goto\");\n        let labelName = null;\n        if (this.next().expect(this.tok.T_STRING)) {\n          labelName = this.node(\"identifier\");\n          const name = this.text();\n          this.next();\n          labelName = labelName(name);\n          this.expectEndOfStatement();\n        }\n        return result(labelName);\n      }\n\n      default: {\n        // default fallback expr\n        const statement = this.node(\"expressionstatement\");\n        const expr = this.read_expr();\n        this.expectEndOfStatement(expr);\n        return statement(expr);\n      }\n    }\n  },\n  /**\n   * ```ebnf\n   *  code_block ::= '{' (inner_statements | top_statements) '}'\n   * ```\n   */\n  read_code_block: function (top) {\n    const result = this.node(\"block\");\n    this.expect(\"{\") && this.next();\n    const body = top\n      ? this.read_top_statements()\n      : this.read_inner_statements();\n    if (\n      body.length === 0 &&\n      this.extractDoc &&\n      this._docs.length > this._docIndex\n    ) {\n      body.push(this.node(\"noop\")());\n    }\n    this.expect(\"}\") && this.next();\n    return result(null, body);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a switch statement\n   * ```ebnf\n   *  switch ::= T_SWITCH '(' expr ')' switch_case_list\n   * ```\n   * @return {Switch}\n   * @see http://php.net/manual/en/control-structures.switch.php\n   */\n  read_switch: function () {\n    const result = this.node(\"switch\");\n    this.expect(this.tok.T_SWITCH) && this.next();\n    this.expect(\"(\") && this.next();\n    const test = this.read_expr();\n    this.expect(\")\") && this.next();\n    const shortForm = this.token === \":\";\n    const body = this.read_switch_case_list();\n    return result(test, body, shortForm);\n  },\n  /**\n   * ```ebnf\n   *  switch_case_list ::= '{' ';'? case_list* '}' | ':' ';'? case_list* T_ENDSWITCH ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L566\n   */\n  read_switch_case_list: function () {\n    // DETECT SWITCH MODE\n    let expect = null;\n    const result = this.node(\"block\");\n    const items = [];\n    if (this.token === \"{\") {\n      expect = \"}\";\n    } else if (this.token === \":\") {\n      expect = this.tok.T_ENDSWITCH;\n    } else {\n      this.expect([\"{\", \":\"]);\n    }\n    this.next();\n    // OPTIONNAL ';'\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L570\n    if (this.token === \";\") {\n      this.next();\n    }\n    // EXTRACTING CASES\n    while (this.token !== this.EOF && this.token !== expect) {\n      items.push(this.read_case_list(expect));\n    }\n    if (\n      items.length === 0 &&\n      this.extractDoc &&\n      this._docs.length > this._docIndex\n    ) {\n      items.push(this.node(\"noop\")());\n    }\n    // CHECK END TOKEN\n    this.expect(expect) && this.next();\n    if (expect === this.tok.T_ENDSWITCH) {\n      this.expectEndOfStatement();\n    }\n    return result(null, items);\n  },\n  /**\n   * ```ebnf\n   *   case_list ::= ((T_CASE expr) | T_DEFAULT) (':' | ';') inner_statement*\n   * ```\n   */\n  read_case_list: function (stopToken) {\n    const result = this.node(\"case\");\n    let test = null;\n    if (this.token === this.tok.T_CASE) {\n      test = this.next().read_expr();\n    } else if (this.token === this.tok.T_DEFAULT) {\n      // the default entry - no condition\n      this.next();\n    } else {\n      this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]);\n    }\n    // case_separator\n    this.expect([\":\", \";\"]) && this.next();\n    const body = this.node(\"block\");\n    const items = [];\n    while (\n      this.token !== this.EOF &&\n      this.token !== stopToken &&\n      this.token !== this.tok.T_CASE &&\n      this.token !== this.tok.T_DEFAULT\n    ) {\n      items.push(this.read_inner_statement());\n    }\n    return result(test, body(null, items));\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   *  try ::= T_TRY '{' inner_statement* '}'\n   *          (\n   *              T_CATCH '(' namespace_name variable ')' '{'  inner_statement* '}'\n   *          )*\n   *          (T_FINALLY '{' inner_statement* '}')?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L448\n   * @return {Try}\n   */\n  read_try: function () {\n    this.expect(this.tok.T_TRY);\n    const result = this.node(\"try\");\n    let always = null;\n    const catches = [];\n    const body = this.next().read_statement();\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L455\n    while (this.token === this.tok.T_CATCH) {\n      const item = this.node(\"catch\");\n      this.next().expect(\"(\") && this.next();\n      const what = this.read_list(this.read_namespace_name, \"|\", false);\n      const variable = this.read_variable(true, false);\n      this.expect(\")\");\n      catches.push(item(this.next().read_statement(), what, variable));\n    }\n    if (this.token === this.tok.T_FINALLY) {\n      always = this.next().read_statement();\n    }\n    return result(body, catches, always);\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a short form of tokens\n   * @param {Number} token - The ending token\n   * @return {Block}\n   */\n  read_short_form: function (token) {\n    const body = this.node(\"block\");\n    const items = [];\n    if (this.expect(\":\")) this.next();\n    while (this.token != this.EOF && this.token !== token) {\n      items.push(this.read_inner_statement());\n    }\n    if (\n      items.length === 0 &&\n      this.extractDoc &&\n      this._docs.length > this._docIndex\n    ) {\n      items.push(this.node(\"noop\")());\n    }\n    if (this.expect(token)) this.next();\n    this.expectEndOfStatement();\n    return body(null, items);\n  },\n\n  /**\n   * https://wiki.php.net/rfc/trailing-comma-function-calls\n   * @param {*} item\n   * @param {*} separator\n   */\n  read_function_list: function (item, separator) {\n    const result = [];\n    do {\n      if (this.token == separator && this.version >= 703 && result.length > 0) {\n        result.push(this.node(\"noop\")());\n        break;\n      }\n      result.push(item.apply(this, []));\n      if (this.token != separator) {\n        break;\n      }\n      if (this.next().token == \")\" && this.version >= 703) {\n        break;\n      }\n    } while (this.token != this.EOF);\n    return result;\n  },\n\n  /**\n   * Helper : reads a list of tokens / sample : T_STRING ',' T_STRING ...\n   * ```ebnf\n   * list ::= separator? ( item separator )* item\n   * ```\n   */\n  read_list: function (item, separator, preserveFirstSeparator) {\n    const result = [];\n\n    if (this.token == separator) {\n      if (preserveFirstSeparator) {\n        result.push(typeof item === \"function\" ? this.node(\"noop\")() : null);\n      }\n      this.next();\n    }\n\n    if (typeof item === \"function\") {\n      do {\n        const itemResult = item.apply(this, []);\n        if (itemResult) {\n          result.push(itemResult);\n        }\n        if (this.token != separator) {\n          break;\n        }\n      } while (this.next().token != this.EOF);\n    } else {\n      if (this.expect(item)) {\n        result.push(this.text());\n      } else {\n        return [];\n      }\n      while (this.next().token != this.EOF) {\n        if (this.token != separator) break;\n        // trim current separator & check item\n        if (this.next().token != item) break;\n        result.push(this.text());\n      }\n    }\n    return result;\n  },\n\n  /**\n   * Reads a list of names separated by a comma\n   *\n   * ```ebnf\n   * name_list ::= namespace (',' namespace)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php class foo extends bar, baz { }\n   * ```\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L726\n   * @return {Reference[]}\n   */\n  read_name_list: function () {\n    return this.read_list(this.read_namespace_name, \",\", false);\n  },\n\n  /**\n   * Reads the byref token and assign it to the specified node\n   * @param {*} cb\n   */\n  read_byref: function (cb) {\n    let byref = this.node(\"byref\");\n    this.next();\n    byref = byref(null);\n    const result = cb();\n    if (result) {\n      this.ast.swapLocations(result, byref, result, this);\n      result.byref = true;\n    }\n    return result;\n  },\n\n  /**\n   * Reads a list of variables declarations\n   *\n   * ```ebnf\n   * variable_declaration ::= T_VARIABLE ('=' expr)?*\n   * variable_declarations ::= variable_declaration (',' variable_declaration)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php static $a = 'hello', $b = 'world';\n   * ```\n   * @return {StaticVariable[]} Returns an array composed by a list of variables, or\n   * assign values\n   */\n  read_variable_declarations: function () {\n    return this.read_list(function () {\n      const node = this.node(\"staticvariable\");\n      let variable = this.node(\"variable\");\n      // plain variable name\n      if (this.expect(this.tok.T_VARIABLE)) {\n        const name = this.text().substring(1);\n        this.next();\n        variable = variable(name, false);\n      } else {\n        variable = variable(\"#ERR\", false);\n      }\n      if (this.token === \"=\") {\n        return node(variable, this.next().read_expr());\n      } else {\n        return variable;\n      }\n    }, \",\");\n  },\n\n  /*\n   * Reads class extends\n   */\n  read_extends_from: function () {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_namespace_name();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads interface extends list\n   */\n  read_interface_extends_list: function () {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads implements list\n   */\n  read_implements_list: function () {\n    if (this.token === this.tok.T_IMPLEMENTS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Reads a variable\n   *\n   * ```ebnf\n   *   variable ::= &? ...complex @todo\n   * ```\n   *\n   * Some samples of parsed code :\n   * ```php\n   *  &$var                      // simple var\n   *  $var                      // simple var\n   *  classname::CONST_NAME     // dynamic class name with const retrieval\n   *  foo()                     // function call\n   *  $var->func()->property    // chained calls\n   * ```\n   */\n  read_variable: function (read_only, encapsed) {\n    let result;\n\n    // check the byref flag\n    if (this.token === \"&\") {\n      return this.read_byref(\n        this.read_variable.bind(this, read_only, encapsed)\n      );\n    }\n\n    // reads the entry point\n    if (this.is([this.tok.T_VARIABLE, \"$\"])) {\n      result = this.read_reference_variable(encapsed);\n    } else if (\n      this.is([\n        this.tok.T_NS_SEPARATOR,\n        this.tok.T_STRING,\n        this.tok.T_NAMESPACE,\n      ])\n    ) {\n      result = this.node();\n      const name = this.read_namespace_name();\n      if (\n        this.token != this.tok.T_DOUBLE_COLON &&\n        this.token != \"(\" &&\n        [\"parentreference\", \"selfreference\"].indexOf(name.kind) === -1\n      ) {\n        // @see parser.js line 130 : resolves a conflict with scalar\n        const literal = name.name.toLowerCase();\n        if (literal === \"true\") {\n          result = name.destroy(result(\"boolean\", true, name.name));\n        } else if (literal === \"false\") {\n          result = name.destroy(result(\"boolean\", false, name.name));\n        } else if (literal === \"null\") {\n          result = name.destroy(result(\"nullkeyword\", name.name));\n        } else {\n          result.destroy(name);\n          result = name;\n        }\n      } else {\n        // @fixme possible #193 bug\n        result.destroy(name);\n        result = name;\n      }\n    } else if (this.token === this.tok.T_STATIC) {\n      result = this.node(\"staticreference\");\n      const raw = this.text();\n      this.next();\n      result = result(raw);\n    } else {\n      this.expect(\"VARIABLE\");\n    }\n\n    // static mode\n    if (this.token === this.tok.T_DOUBLE_COLON) {\n      result = this.read_static_getter(result, encapsed);\n    }\n\n    return this.recursive_variable_chain_scan(result, read_only, encapsed);\n  },\n\n  // resolves a static call\n  read_static_getter: function (what, encapsed) {\n    const result = this.node(\"staticlookup\");\n    let offset, name;\n    if (this.next().is([this.tok.T_VARIABLE, \"$\"])) {\n      offset = this.read_reference_variable(encapsed);\n    } else if (\n      this.token === this.tok.T_STRING ||\n      this.token === this.tok.T_CLASS ||\n      (this.version >= 700 && this.is(\"IDENTIFIER\"))\n    ) {\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    } else if (this.token === \"{\") {\n      offset = this.node(\"literal\");\n      name = this.next().read_expr();\n      this.expect(\"}\") && this.next();\n      offset = offset(\"literal\", name, null);\n      this.expect(\"(\");\n    } else {\n      this.error([this.tok.T_VARIABLE, this.tok.T_STRING]);\n      // graceful mode : set getter as error node and continue\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    }\n    return result(what, offset);\n  },\n\n  read_what: function (is_static_lookup = false) {\n    let what = null;\n    let name = null;\n    switch (this.next().token) {\n      case this.tok.T_STRING:\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n\n        if (is_static_lookup && this.token === this.tok.T_OBJECT_OPERATOR) {\n          this.error();\n        }\n        break;\n      case this.tok.T_VARIABLE:\n        what = this.node(\"variable\");\n        name = this.text().substring(1);\n        this.next();\n        what = what(name, false);\n        break;\n      case \"$\":\n        what = this.node();\n        this.next().expect([\"$\", \"{\", this.tok.T_VARIABLE]);\n        if (this.token === \"{\") {\n          // $obj->${$varname}\n          name = this.next().read_expr();\n          this.expect(\"}\") && this.next();\n          what = what(\"variable\", name, true);\n        } else {\n          // $obj->$$varname\n          name = this.read_expr();\n          what = what(\"variable\", name, false);\n        }\n        break;\n      case \"{\":\n        what = this.node(\"encapsedpart\");\n        name = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        what = what(name, \"complex\", false);\n        break;\n      default:\n        this.error([this.tok.T_STRING, this.tok.T_VARIABLE, \"$\", \"{\"]);\n        // graceful mode : set what as error mode & continue\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n        break;\n    }\n\n    return what;\n  },\n\n  recursive_variable_chain_scan: function (result, read_only, encapsed) {\n    let node, offset;\n    recursive_scan_loop: while (this.token != this.EOF) {\n      switch (this.token) {\n        case \"(\":\n          if (read_only) {\n            // @fixme : add more informations & test\n            return result;\n          } else {\n            result = this.node(\"call\")(result, this.read_argument_list());\n          }\n          break;\n        case \"[\":\n        case \"{\": {\n          const backet = this.token;\n          const isSquareBracket = backet === \"[\";\n          node = this.node(\"offsetlookup\");\n          this.next();\n          offset = false;\n          if (encapsed) {\n            offset = this.read_encaps_var_offset();\n            this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n          } else {\n            const isCallableVariable = isSquareBracket\n              ? this.token !== \"]\"\n              : this.token !== \"}\";\n            // callable_variable : https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1122\n            if (isCallableVariable) {\n              offset = this.read_expr();\n              this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n            } else {\n              this.next();\n            }\n          }\n          result = node(result, offset);\n          break;\n        }\n        case this.tok.T_DOUBLE_COLON:\n          // @see https://github.com/glayzzle/php-parser/issues/107#issuecomment-354104574\n          if (\n            result.kind === \"staticlookup\" &&\n            result.offset.kind === \"identifier\"\n          ) {\n            this.error();\n          }\n\n          node = this.node(\"staticlookup\");\n          result = node(result, this.read_what(true));\n\n          // fix 185\n          // static lookup dereferencables are limited to staticlookup over functions\n          /*if (dereferencable && this.token !== \"(\") {\n            this.error(\"(\");\n          }*/\n          break;\n        case this.tok.T_OBJECT_OPERATOR: {\n          node = this.node(\"propertylookup\");\n          result = node(result, this.read_what());\n          break;\n        }\n        default:\n          break recursive_scan_loop;\n      }\n    }\n    return result;\n  },\n  /**\n   * https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1231\n   */\n  read_encaps_var_offset: function () {\n    let offset = this.node();\n    if (this.token === this.tok.T_STRING) {\n      const text = this.text();\n      this.next();\n      offset = offset(\"identifier\", text);\n    } else if (this.token === this.tok.T_NUM_STRING) {\n      const num = this.text();\n      this.next();\n      offset = offset(\"number\", num, null);\n    } else if (this.token === \"-\") {\n      this.next();\n      const num = -1 * this.text();\n      this.expect(this.tok.T_NUM_STRING) && this.next();\n      offset = offset(\"number\", num, null);\n    } else if (this.token === this.tok.T_VARIABLE) {\n      const name = this.text().substring(1);\n      this.next();\n      offset = offset(\"variable\", name, false);\n    } else {\n      this.expect([\n        this.tok.T_STRING,\n        this.tok.T_NUM_STRING,\n        \"-\",\n        this.tok.T_VARIABLE,\n      ]);\n      // fallback : consider as identifier\n      const text = this.text();\n      this.next();\n      offset = offset(\"identifier\", text);\n    }\n    return offset;\n  },\n  /**\n   * ```ebnf\n   *  reference_variable ::=  simple_variable ('[' OFFSET ']')* | '{' EXPR '}'\n   * ```\n   * <code>\n   *  $foo[123];      // foo is an array ==> gets its entry\n   *  $foo{1};        // foo is a string ==> get the 2nd char offset\n   *  ${'foo'}[123];  // get the dynamic var $foo\n   *  $foo[123]{1};   // gets the 2nd char from the 123 array entry\n   * </code>\n   */\n  read_reference_variable: function (encapsed) {\n    let result = this.read_simple_variable();\n    let offset;\n    while (this.token != this.EOF) {\n      const node = this.node();\n      if (this.token == \"{\" && !encapsed) {\n        // @fixme check coverage, not sure thats working\n        offset = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        result = node(\"offsetlookup\", result, offset);\n      } else {\n        node.destroy();\n        break;\n      }\n    }\n    return result;\n  },\n  /**\n   * ```ebnf\n   *  simple_variable ::= T_VARIABLE | '$' '{' expr '}' | '$' simple_variable\n   * ```\n   */\n  read_simple_variable: function () {\n    let result = this.node(\"variable\");\n    let name;\n    if (\n      this.expect([this.tok.T_VARIABLE, \"$\"]) &&\n      this.token === this.tok.T_VARIABLE\n    ) {\n      // plain variable name\n      name = this.text().substring(1);\n      this.next();\n      result = result(name, false);\n    } else {\n      if (this.token === \"$\") this.next();\n      // dynamic variable name\n      switch (this.token) {\n        case \"{\": {\n          const expr = this.next().read_expr();\n          this.expect(\"}\") && this.next();\n          result = result(expr, true);\n          break;\n        }\n        case \"$\": // $$$var\n          result = result(this.read_simple_variable(), false);\n          break;\n        case this.tok.T_VARIABLE: {\n          // $$var\n          name = this.text().substring(1);\n          const node = this.node(\"variable\");\n          this.next();\n          result = result(node(name, false), false);\n          break;\n        }\n        default:\n          this.error([\"{\", \"$\", this.tok.T_VARIABLE]);\n          // graceful mode\n          name = this.text();\n          this.next();\n          result = result(name, false);\n      }\n    }\n    return result;\n  },\n};\n","/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\"use strict\";\n\n/**\n * PHP AST Tokens\n * @type {Object}\n */\nmodule.exports = {\n  values: {\n    101: \"T_HALT_COMPILER\",\n    102: \"T_USE\",\n    103: \"T_ENCAPSED_AND_WHITESPACE\",\n    104: \"T_OBJECT_OPERATOR\",\n    105: \"T_STRING\",\n    106: \"T_DOLLAR_OPEN_CURLY_BRACES\",\n    107: \"T_STRING_VARNAME\",\n    108: \"T_CURLY_OPEN\",\n    109: \"T_NUM_STRING\",\n    110: \"T_ISSET\",\n    111: \"T_EMPTY\",\n    112: \"T_INCLUDE\",\n    113: \"T_INCLUDE_ONCE\",\n    114: \"T_EVAL\",\n    115: \"T_REQUIRE\",\n    116: \"T_REQUIRE_ONCE\",\n    117: \"T_NAMESPACE\",\n    118: \"T_NS_SEPARATOR\",\n    119: \"T_AS\",\n    120: \"T_IF\",\n    121: \"T_ENDIF\",\n    122: \"T_WHILE\",\n    123: \"T_DO\",\n    124: \"T_FOR\",\n    125: \"T_SWITCH\",\n    126: \"T_BREAK\",\n    127: \"T_CONTINUE\",\n    128: \"T_RETURN\",\n    129: \"T_GLOBAL\",\n    130: \"T_STATIC\",\n    131: \"T_ECHO\",\n    132: \"T_INLINE_HTML\",\n    133: \"T_UNSET\",\n    134: \"T_FOREACH\",\n    135: \"T_DECLARE\",\n    136: \"T_TRY\",\n    137: \"T_THROW\",\n    138: \"T_GOTO\",\n    139: \"T_FINALLY\",\n    140: \"T_CATCH\",\n    141: \"T_ENDDECLARE\",\n    142: \"T_LIST\",\n    143: \"T_CLONE\",\n    144: \"T_PLUS_EQUAL\",\n    145: \"T_MINUS_EQUAL\",\n    146: \"T_MUL_EQUAL\",\n    147: \"T_DIV_EQUAL\",\n    148: \"T_CONCAT_EQUAL\",\n    149: \"T_MOD_EQUAL\",\n    150: \"T_AND_EQUAL\",\n    151: \"T_OR_EQUAL\",\n    152: \"T_XOR_EQUAL\",\n    153: \"T_SL_EQUAL\",\n    154: \"T_SR_EQUAL\",\n    155: \"T_INC\",\n    156: \"T_DEC\",\n    157: \"T_BOOLEAN_OR\",\n    158: \"T_BOOLEAN_AND\",\n    159: \"T_LOGICAL_OR\",\n    160: \"T_LOGICAL_AND\",\n    161: \"T_LOGICAL_XOR\",\n    162: \"T_SL\",\n    163: \"T_SR\",\n    164: \"T_IS_IDENTICAL\",\n    165: \"T_IS_NOT_IDENTICAL\",\n    166: \"T_IS_EQUAL\",\n    167: \"T_IS_NOT_EQUAL\",\n    168: \"T_IS_SMALLER_OR_EQUAL\",\n    169: \"T_IS_GREATER_OR_EQUAL\",\n    170: \"T_INSTANCEOF\",\n    171: \"T_INT_CAST\",\n    172: \"T_DOUBLE_CAST\",\n    173: \"T_STRING_CAST\",\n    174: \"T_ARRAY_CAST\",\n    175: \"T_OBJECT_CAST\",\n    176: \"T_BOOL_CAST\",\n    177: \"T_UNSET_CAST\",\n    178: \"T_EXIT\",\n    179: \"T_PRINT\",\n    180: \"T_YIELD\",\n    181: \"T_YIELD_FROM\",\n    182: \"T_FUNCTION\",\n    183: \"T_DOUBLE_ARROW\",\n    184: \"T_DOUBLE_COLON\",\n    185: \"T_ARRAY\",\n    186: \"T_CALLABLE\",\n    187: \"T_CLASS\",\n    188: \"T_ABSTRACT\",\n    189: \"T_TRAIT\",\n    190: \"T_FINAL\",\n    191: \"T_EXTENDS\",\n    192: \"T_INTERFACE\",\n    193: \"T_IMPLEMENTS\",\n    194: \"T_VAR\",\n    195: \"T_PUBLIC\",\n    196: \"T_PROTECTED\",\n    197: \"T_PRIVATE\",\n    198: \"T_CONST\",\n    199: \"T_NEW\",\n    200: \"T_INSTEADOF\",\n    201: \"T_ELSEIF\",\n    202: \"T_ELSE\",\n    203: \"T_ENDSWITCH\",\n    204: \"T_CASE\",\n    205: \"T_DEFAULT\",\n    206: \"T_ENDFOR\",\n    207: \"T_ENDFOREACH\",\n    208: \"T_ENDWHILE\",\n    209: \"T_CONSTANT_ENCAPSED_STRING\",\n    210: \"T_LNUMBER\",\n    211: \"T_DNUMBER\",\n    212: \"T_LINE\",\n    213: \"T_FILE\",\n    214: \"T_DIR\",\n    215: \"T_TRAIT_C\",\n    216: \"T_METHOD_C\",\n    217: \"T_FUNC_C\",\n    218: \"T_NS_C\",\n    219: \"T_START_HEREDOC\",\n    220: \"T_END_HEREDOC\",\n    221: \"T_CLASS_C\",\n    222: \"T_VARIABLE\",\n    223: \"T_OPEN_TAG\",\n    224: \"T_OPEN_TAG_WITH_ECHO\",\n    225: \"T_CLOSE_TAG\",\n    226: \"T_WHITESPACE\",\n    227: \"T_COMMENT\",\n    228: \"T_DOC_COMMENT\",\n    229: \"T_ELLIPSIS\",\n    230: \"T_COALESCE\",\n    231: \"T_POW\",\n    232: \"T_POW_EQUAL\",\n    233: \"T_SPACESHIP\",\n    234: \"T_COALESCE_EQUAL\",\n    235: \"T_FN\",\n  },\n  names: {\n    T_HALT_COMPILER: 101,\n    T_USE: 102,\n    T_ENCAPSED_AND_WHITESPACE: 103,\n    T_OBJECT_OPERATOR: 104,\n    T_STRING: 105,\n    T_DOLLAR_OPEN_CURLY_BRACES: 106,\n    T_STRING_VARNAME: 107,\n    T_CURLY_OPEN: 108,\n    T_NUM_STRING: 109,\n    T_ISSET: 110,\n    T_EMPTY: 111,\n    T_INCLUDE: 112,\n    T_INCLUDE_ONCE: 113,\n    T_EVAL: 114,\n    T_REQUIRE: 115,\n    T_REQUIRE_ONCE: 116,\n    T_NAMESPACE: 117,\n    T_NS_SEPARATOR: 118,\n    T_AS: 119,\n    T_IF: 120,\n    T_ENDIF: 121,\n    T_WHILE: 122,\n    T_DO: 123,\n    T_FOR: 124,\n    T_SWITCH: 125,\n    T_BREAK: 126,\n    T_CONTINUE: 127,\n    T_RETURN: 128,\n    T_GLOBAL: 129,\n    T_STATIC: 130,\n    T_ECHO: 131,\n    T_INLINE_HTML: 132,\n    T_UNSET: 133,\n    T_FOREACH: 134,\n    T_DECLARE: 135,\n    T_TRY: 136,\n    T_THROW: 137,\n    T_GOTO: 138,\n    T_FINALLY: 139,\n    T_CATCH: 140,\n    T_ENDDECLARE: 141,\n    T_LIST: 142,\n    T_CLONE: 143,\n    T_PLUS_EQUAL: 144,\n    T_MINUS_EQUAL: 145,\n    T_MUL_EQUAL: 146,\n    T_DIV_EQUAL: 147,\n    T_CONCAT_EQUAL: 148,\n    T_MOD_EQUAL: 149,\n    T_AND_EQUAL: 150,\n    T_OR_EQUAL: 151,\n    T_XOR_EQUAL: 152,\n    T_SL_EQUAL: 153,\n    T_SR_EQUAL: 154,\n    T_INC: 155,\n    T_DEC: 156,\n    T_BOOLEAN_OR: 157,\n    T_BOOLEAN_AND: 158,\n    T_LOGICAL_OR: 159,\n    T_LOGICAL_AND: 160,\n    T_LOGICAL_XOR: 161,\n    T_SL: 162,\n    T_SR: 163,\n    T_IS_IDENTICAL: 164,\n    T_IS_NOT_IDENTICAL: 165,\n    T_IS_EQUAL: 166,\n    T_IS_NOT_EQUAL: 167,\n    T_IS_SMALLER_OR_EQUAL: 168,\n    T_IS_GREATER_OR_EQUAL: 169,\n    T_INSTANCEOF: 170,\n    T_INT_CAST: 171,\n    T_DOUBLE_CAST: 172,\n    T_STRING_CAST: 173,\n    T_ARRAY_CAST: 174,\n    T_OBJECT_CAST: 175,\n    T_BOOL_CAST: 176,\n    T_UNSET_CAST: 177,\n    T_EXIT: 178,\n    T_PRINT: 179,\n    T_YIELD: 180,\n    T_YIELD_FROM: 181,\n    T_FUNCTION: 182,\n    T_DOUBLE_ARROW: 183,\n    T_DOUBLE_COLON: 184,\n    T_ARRAY: 185,\n    T_CALLABLE: 186,\n    T_CLASS: 187,\n    T_ABSTRACT: 188,\n    T_TRAIT: 189,\n    T_FINAL: 190,\n    T_EXTENDS: 191,\n    T_INTERFACE: 192,\n    T_IMPLEMENTS: 193,\n    T_VAR: 194,\n    T_PUBLIC: 195,\n    T_PROTECTED: 196,\n    T_PRIVATE: 197,\n    T_CONST: 198,\n    T_NEW: 199,\n    T_INSTEADOF: 200,\n    T_ELSEIF: 201,\n    T_ELSE: 202,\n    T_ENDSWITCH: 203,\n    T_CASE: 204,\n    T_DEFAULT: 205,\n    T_ENDFOR: 206,\n    T_ENDFOREACH: 207,\n    T_ENDWHILE: 208,\n    T_CONSTANT_ENCAPSED_STRING: 209,\n    T_LNUMBER: 210,\n    T_DNUMBER: 211,\n    T_LINE: 212,\n    T_FILE: 213,\n    T_DIR: 214,\n    T_TRAIT_C: 215,\n    T_METHOD_C: 216,\n    T_FUNC_C: 217,\n    T_NS_C: 218,\n    T_START_HEREDOC: 219,\n    T_END_HEREDOC: 220,\n    T_CLASS_C: 221,\n    T_VARIABLE: 222,\n    T_OPEN_TAG: 223,\n    T_OPEN_TAG_WITH_ECHO: 224,\n    T_CLOSE_TAG: 225,\n    T_WHITESPACE: 226,\n    T_COMMENT: 227,\n    T_DOC_COMMENT: 228,\n    T_ELLIPSIS: 229,\n    T_COALESCE: 230,\n    T_POW: 231,\n    T_POW_EQUAL: 232,\n    T_SPACESHIP: 233,\n    T_COALESCE_EQUAL: 234,\n    T_FN: 235,\n  },\n};\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","/* eslint-env node */\n'use strict';\n\nconst fs = require('fs');\nconst matched = require('matched');\nconst pathSort = require('path-sort');\n\nconst TranslationParser = require('./translation-parser');\nconst PotMaker = require('./pot-maker');\n\n/**\n * Set default options\n *\n * @param {object} options\n *\n * @return {object}\n */\nfunction setDefaultOptions (options) {\n  const defaultOptions = {\n    src: '**/*.php',\n    globOpts: {},\n    destFile: 'translations.pot',\n    commentKeyword: 'translators:',\n    headers: {\n      'X-Poedit-Basepath': '..',\n      'X-Poedit-SourceCharset': 'UTF-8',\n      'X-Poedit-SearchPath-0': '.',\n      'X-Poedit-SearchPathExcluded-0': '*.js'\n    },\n    defaultHeaders: true,\n    noFilePaths: false,\n    writeFile: true,\n    gettextFunctions: [\n      { name: '__' },\n      { name: '_e' },\n      { name: '_ex', context: 2 },\n      { name: '_n', plural: 2 },\n      { name: '_n_noop', plural: 2 },\n      { name: '_nx', plural: 2, context: 4 },\n      { name: '_nx_noop', plural: 2, context: 3 },\n      { name: '_x', context: 2 },\n      { name: 'esc_attr__' },\n      { name: 'esc_attr_e' },\n      { name: 'esc_attr_x', context: 2 },\n      { name: 'esc_html__' },\n      { name: 'esc_html_e' },\n      { name: 'esc_html_x', context: 2 }\n    ],\n    ignoreTemplateNameHeader: false\n  };\n\n  if (options.headers === false) {\n    options.defaultHeaders = false;\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!options.package) {\n    options.package = options.domain || 'unnamed project';\n  }\n\n  const functionCalls = {\n    valid: [],\n    contextPosition: {},\n    pluralPosition: {}\n  };\n\n  options.gettextFunctions.forEach(function (methodObject) {\n    functionCalls.valid.push(methodObject.name);\n\n    if (methodObject.plural) {\n      functionCalls.pluralPosition[methodObject.name] = methodObject.plural;\n    }\n    if (methodObject.context) {\n      functionCalls.contextPosition[methodObject.name] = methodObject.context;\n    }\n  });\n\n  options.functionCalls = functionCalls;\n\n  return options;\n}\n\n/**\n * Generate string for header from gettext function\n *\n * @param {object} gettextFunctions\n *\n * @return {Array}\n */\nfunction keywordsListStrings (gettextFunctions) {\n  const methodStrings = [];\n\n  for (const getTextFunction of gettextFunctions) {\n    let methodString = getTextFunction.name;\n\n    if (getTextFunction.plural || getTextFunction.context) {\n      methodString += ':1';\n    }\n    if (getTextFunction.plural) {\n      methodString += `,${getTextFunction.plural}`;\n    }\n    if (getTextFunction.context) {\n      methodString += `,${getTextFunction.context}c`;\n    }\n\n    methodStrings.push(methodString);\n  }\n\n  return methodStrings;\n}\n\n/**\n * Set default pot headers\n *\n * @param {object} options\n *\n * @return {object}\n */\nfunction setHeaders (options) {\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  if (options.bugReport) {\n    options.headers['Report-Msgid-Bugs-To'] = options.bugReport;\n  }\n\n  if (options.lastTranslator) {\n    options.headers['Last-Translator'] = options.lastTranslator;\n  }\n\n  if (options.team) {\n    options.headers['Language-Team'] = options.team;\n  }\n\n  if (options.defaultHeaders && !Object.prototype.hasOwnProperty.call(options.headers, 'X-Poedit-KeywordsList')) {\n    options.headers['X-Poedit-KeywordsList'] = keywordsListStrings(options.gettextFunctions).join(';');\n  }\n\n  return options;\n}\n\n/**\n * Write file to disk\n *\n * @param {string} potContent\n * @param {object} options\n */\nfunction writePot (potContent, options) {\n  fs.writeFileSync(options.destFile, potContent);\n}\n\n/**\n * Constructor\n * @param {object} options\n * @return {string}\n */\nfunction wpPot (options) {\n  // Reset states\n  let translations = {};\n\n  // Set options\n  options = setDefaultOptions(options);\n\n  // Find and sort file paths\n  const files = pathSort(matched.sync(options.src, options.globOpts));\n\n  // Parse files\n  for (const file of files) {\n    const filecontent = fs.readFileSync(file).toString();\n    const translationParser = new TranslationParser(options);\n    translations = translationParser.parseFile(filecontent, file, translations);\n  }\n\n  options = setHeaders(options);\n\n  const potMaker = new PotMaker(options);\n  const potContents = potMaker.generatePot(translations);\n\n  if (options.writeFile) {\n    writePot(potContents, options);\n  }\n\n  return potContents;\n}\n\nmodule.exports = wpPot;\n","/* eslint-env node */\n'use strict';\n\nclass PotMaker {\n  constructor (options) {\n    this.options = options;\n  }\n\n  /**\n   * Check if variable is a empty object\n   *\n   * @param  {object}  obj\n   *\n   * @return {boolean}\n   */\n  static isEmptyObject (obj) {\n    return Object.keys(obj).length === 0;\n  }\n\n  /**\n   * Escape unescaped double quotes\n   *\n   * @param {string} text\n   * @return string\n   */\n  static escapeQuotes (text) {\n    text = text.replace(/\\\\([\\s\\S])|(\")/g, '\\\\$1$2');\n    return text;\n  }\n\n  /**\n   * Get msgid lines in pot format\n   *\n   * @param {string}  msgid\n   * @param {Boolean} [plural]\n   *\n   * @return {Array}\n   */\n  static getPotMsgId (msgid, plural) {\n    const output = [];\n    const idKey = (plural ? 'msgid_plural' : 'msgid');\n\n    if (msgid) {\n      msgid = PotMaker.escapeQuotes(msgid);\n\n      if (/\\n/.test(msgid)) {\n        output.push(`${idKey} \"\"`);\n        const rows = msgid.split(/\\n/);\n\n        for (let rowId = 0; rowId < rows.length; rowId++) {\n          const lineBreak = rowId === (rows.length - 1) ? '' : '\\\\n';\n\n          output.push(`\"${rows[rowId] + lineBreak}\"`);\n        }\n      } else {\n        output.push(`${idKey} \"${msgid}\"`);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Get msgstr lines in pot format\n   *\n   * @param {Boolean} plural\n   *\n   * @return {Array}\n   */\n  static getPotMsgStr (plural) {\n    if (!plural) {\n      return ['msgstr \"\"\\n'];\n    } else {\n      return ['msgstr[0] \"\"', 'msgstr[1] \"\"\\n'];\n    }\n  }\n\n  /**\n   * Write translation to array with pot format.\n   *\n   * @param {object} translations\n   * @param {bool}   noFilePaths\n   *\n   * @return {Array}\n   */\n  static translationToPot (translations, noFilePaths) {\n    // Write translation rows.\n    let output = [];\n\n    if (translations) {\n      for (const translationElement of Object.keys(translations)) {\n        if (translations[translationElement].comment) {\n          for (const comment of translations[translationElement].comment) {\n            output.push(`#. ${comment}`);\n          }\n        }\n\n        if (!noFilePaths) {\n          // Unify paths for Unix and Windows\n          output.push(`#: ${translations[translationElement].info.replace(/\\\\/g, '/')}`);\n        }\n\n        if (translations[translationElement].msgctxt) {\n          output.push(`msgctxt \"${PotMaker.escapeQuotes(translations[translationElement].msgctxt)}\"`);\n        }\n\n        output = output.concat(PotMaker.getPotMsgId(translations[translationElement].msgid));\n\n        output = output.concat(PotMaker.getPotMsgId(translations[translationElement].msgid_plural, true));\n\n        output = output.concat(PotMaker.getPotMsgStr(Boolean(translations[translationElement].msgid_plural)));\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Sort object by key name\n   *\n   * @param {object} obj\n   */\n  sortObject (obj) {\n    return Object.keys(obj).sort().reduce(function (result, key) {\n      result[key] = obj[key];\n      return result;\n    }, {});\n  }\n\n  /**\n   * Geneate pot contents\n   *\n   * @param {object} translations\n   *\n   * @return {string}\n   */\n  generatePot (translations) {\n    const year = new Date().getFullYear();\n\n    let contents = (\n      `# Copyright (C) ${year} ${this.options.package}\n# This file is distributed under the same license as the ${this.options.package} package.\nmsgid \"\"\nmsgstr \"\"\n\"Project-Id-Version: ${this.options.package}\\\\n\"\n\"MIME-Version: 1.0\\\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\\\n\"\n\"Content-Transfer-Encoding: 8bit\\\\n\"\\n`);\n\n    if (this.options.headers && !PotMaker.isEmptyObject(this.options.headers)) {\n      this.options.headers = this.sortObject(this.options.headers);\n\n      for (const key of Object.keys(this.options.headers)) {\n        contents += `\"${key}: ${this.options.headers[key]}\\\\n\"\\n`;\n      }\n    }\n\n    contents += '\"Plural-Forms: nplurals=2; plural=(n != 1);\\\\n\"\\n';\n    contents += '\\n';\n\n    const translationLines = PotMaker.translationToPot(translations, this.options.noFilePaths);\n    contents += translationLines.join('\\n');\n\n    return contents;\n  }\n}\n\nmodule.exports = PotMaker;\n","/* eslint-env node */\n'use strict';\n\nconst path = require('path');\nconst Engine = require('php-parser');\nconst parser = new Engine({\n  parser: {\n    extractDoc: true\n  },\n  ast: {\n    withPositions: true\n  },\n  lexer: {\n    short_tags: true\n  }\n});\n\nfunction objectHas (obj, key) {\n  if (!obj || typeof obj !== 'object') return false;\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction replaceAll (string, search, replace) {\n  return string.split(search).join(replace);\n}\n\nclass TranslationParser {\n  constructor (options) {\n    this.options = options;\n    this.translations = [];\n    this.comments = {};\n  }\n\n  /**\n   * Parse theme or plugin meta data from file header\n   *\n   * @param {Array} headers\n   * @param {string} filecontent\n   * @param {string} filename\n   */\n  parseFileHeader (headers, filecontent, filename) {\n    const _this = this;\n    const lines = filecontent.match(/[^\\r\\n]+/g);\n\n    if (lines) {\n      lines.splice(30);\n\n      lines.forEach(function (lineContent, line) {\n        headers.forEach(function (header, index) {\n          const regex = new RegExp('^(?:[ \\t]*<?php)?[ \\t/*#@]*' + header + ':(.*)$', 'i');\n          const match = regex.exec(lineContent);\n\n          if (match) {\n            headers.splice(index, 1);\n            const headerValue = match[1].replace(/\\s*(?:\\*\\/|\\?>).*/, '').trim();\n\n            const translationCall = {\n              args: [headerValue],\n              filename,\n              line: line + 1,\n              method: ''\n            };\n\n            _this.addTranslation(translationCall);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Parse comment AST\n   *\n   * @param  {object} commentAst\n   */\n  parseComment (commentAst) {\n    let commentRegexp;\n    if (commentAst.kind === 'commentblock') {\n      commentRegexp = new RegExp(`(?:\\\\/\\\\*)?[\\\\s*]*${this.options.commentKeyword}(.*)\\\\s*(?:\\\\*\\\\/)$`, 'im');\n    } else {\n      commentRegexp = new RegExp(`^\\\\/\\\\/\\\\s*${this.options.commentKeyword}(.*)$`, 'im');\n    }\n    const commentParts = commentRegexp.exec(commentAst.value);\n\n    if (commentParts) {\n      let lineNumber = commentAst.loc.end.line;\n      if (commentAst.loc.end.column === 0) {\n        lineNumber--;\n      }\n\n      this.comments[lineNumber] = commentParts[1];\n    }\n  }\n\n  /**\n   * Parse arguments in a function call\n   *\n   * @param {Array} args\n   *\n   * @return {Array}\n   */\n  static parseArguments (args) {\n    const argsArray = [];\n    for (const arg of args) {\n      if (arg.kind === 'propertylookup') {\n        argsArray.push(`$${arg.what.name}->${arg.offset.name}`);\n      } else if (arg.kind === 'staticlookup') {\n        argsArray.push(`$${arg.what.name}::${arg.offset.name}`);\n      } else if (arg.kind === 'variable') {\n        argsArray.push(`$${arg.name}`);\n      } else if (arg.kind === 'name' && arg.resolution === 'uqn') {\n        argsArray.push(arg.name);\n      } else {\n        argsArray.push(arg.value);\n      }\n    }\n\n    return argsArray;\n  }\n\n  /**\n   * Get context argument position\n   *\n   * @param {string} method\n   *\n   * @return {number}\n   */\n  getContextPos (method) {\n    return this.options.functionCalls.contextPosition[method] - 1;\n  }\n\n  /**\n   * Generate a object for a translation\n   *\n   * @param {object} translationCall\n   * @return {object}\n   */\n  generateTranslationObject (translationCall) {\n    const translationObject = {\n      info: `${translationCall.filename}:${translationCall.line}`,\n      msgid: translationCall.args[0],\n      comment: []\n    };\n\n    if (translationCall.comment) {\n      translationObject.comment.push(this.options.commentKeyword + translationCall.comment);\n    }\n\n    if (objectHas(this.options.functionCalls.pluralPosition, translationCall.method)) {\n      translationObject.msgid_plural = translationCall.args[1];\n    }\n\n    if (objectHas(this.options.functionCalls.contextPosition, translationCall.method)) {\n      const contextKey = this.getContextPos(translationCall.method);\n      translationObject.msgctxt = translationCall.args[contextKey];\n    }\n\n    return translationObject;\n  }\n\n  /**\n   * Generate key to match duplicate translations\n   *\n   * @param {object} translationObject\n   * @return {string}\n   */\n  static generateTranslationKey (translationObject) {\n    return `${translationObject.msgid}${(translationObject.msgctxt)}`;\n  }\n\n  /**\n   * Add translation call to array\n   *\n   * @param {object} translationCall\n   */\n  addTranslation (translationCall) {\n    if (translationCall.args) {\n      const translationObject = this.generateTranslationObject(translationCall);\n\n      const translationKey = TranslationParser.generateTranslationKey(translationObject);\n      if (!this.translations[translationKey]) {\n        this.translations[translationKey] = translationObject;\n      } else {\n        this.translations[translationKey].info += `, ${translationObject.info}`;\n\n        if (translationObject.msgid_plural) {\n          this.translations[translationKey].msgid_plural = translationObject.msgid_plural;\n        }\n\n        if (translationObject.comment[0]) {\n          this.translations[translationKey].comment.push(translationObject.comment[0]);\n        }\n      }\n    }\n  }\n\n  getComment (lineNumber) {\n    const linesWithComment = Object.keys(this.comments);\n    if (!linesWithComment) {\n      return null;\n    }\n\n    if (linesWithComment[0] > lineNumber) {\n      return null;\n    }\n\n    let comment;\n    if (lineNumber - linesWithComment[0] > 2) {\n      delete this.comments[linesWithComment[0]];\n      comment = this.getComment(lineNumber);\n    } else {\n      comment = this.comments[linesWithComment[0]];\n      delete this.comments[linesWithComment[0]];\n    }\n\n    if (comment) {\n      comment = comment.replace(/\\s+$/, '');\n    }\n\n    return comment;\n  }\n\n  /**\n   * Check if ast is a valid function call\n   *\n   * @param {object} ast\n   *\n   * @return {string|null}\n   */\n  validFunctionCall (ast) {\n    if (ast.kind === 'call') {\n      let methodName = ast.what.name;\n\n      if (ast.what.kind === 'propertylookup' && ast.what.what.kind === 'variable') {\n        methodName = ['$', ast.what.what.name, '->', ast.what.offset.name].join('');\n      } else if (ast.what.kind === 'name' && ast.what.resolution === 'fqn') {\n        methodName = ast.what.name.replace(/^\\\\/, '');\n      }\n\n      if (this.options.functionCalls.valid.indexOf(methodName) !== -1) {\n        return methodName;\n      }\n    }\n\n    return null;\n  }\n\n  validArgs (methodName, args) {\n    if (args[0] && args[0].kind !== 'string') {\n      return false;\n    }\n\n    if (objectHas(this.options.functionCalls.pluralPosition, methodName) && args[1] && args[1].kind !== 'string') {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Parse the AST code tree\n   *\n   * @param {object} ast\n   * @param {string} filename\n   */\n  parseCodeTree (ast, filename) {\n    if (!ast) {\n      return;\n    }\n\n    if (ast.comments) {\n      for (const comment of ast.comments) {\n        this.parseComment(comment);\n      }\n    }\n\n    if (Array.isArray(ast)) {\n      for (const child of ast) {\n        this.parseCodeTree(child, filename);\n      }\n      return;\n    }\n\n    const methodName = this.validFunctionCall(ast);\n\n    if (methodName) {\n      const args = TranslationParser.parseArguments(ast.arguments);\n\n      if ((!this.options.domain || this.options.domain === args[args.length - 1]) && this.validArgs(methodName, ast.arguments)) {\n        const translationCall = {\n          args,\n          filename,\n          line: ast.loc.start.line,\n          method: methodName,\n          comment: this.getComment(ast.loc.start.line)\n        };\n\n        this.addTranslation(translationCall);\n      }\n    } else {\n      // List can not be in alphabetic order, otherwise it will not be ordered by occurence in code.\n      const childrenContainingCalls = [\n        'arguments',\n        'alternate',\n        'body',\n        'catches',\n        'children',\n        'expr',\n        'expression',\n        'expressions',\n        'trueExpr',\n        'falseExpr',\n        'items',\n        'key',\n        'left',\n        'right',\n        'value',\n        'what'\n      ];\n\n      for (const child of childrenContainingCalls) {\n        if (ast[child]) {\n          this.parseCodeTree(ast[child], filename);\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse PHP file\n   *\n   * @param {string} filecontent\n   * @param {string} filePath\n   * @param {object} existingTranslations\n   *\n   * @return {Array}\n   */\n  parseFile (filecontent, filePath, existingTranslations) {\n    if (existingTranslations === undefined) {\n      existingTranslations = {};\n    }\n\n    this.translations = existingTranslations;\n\n    const filename = path.relative(this.options.relativeTo || path.dirname(this.options.destFile || __filename), filePath).replace(/\\\\/g, '/');\n\n    if (this.options.metadataFile === filename) {\n      this.parseFileHeader(['Plugin Name', 'Theme Name', 'Description', 'Author', 'Author URI', 'Plugin URI', 'Theme URI'], filecontent, filename);\n    }\n\n    if (!this.options.ignoreTemplateNameHeader) {\n      this.parseFileHeader(['Template Name'], filecontent, filename);\n    }\n\n    // Skip file if no translation functions is found\n    const validFunctionsInFile = new RegExp(replaceAll(this.options.functionCalls.valid.join('|'), '$', '\\\\$'));\n\n    if (validFunctionsInFile.test(filecontent)) {\n      try {\n        const ast = parser.parseCode(filecontent, filename);\n        this.parseCodeTree(ast, filename);\n      } catch (e) {\n        e.message += ` | Unable to parse ${filename}`;\n        throw e;\n      }\n    }\n\n    return this.translations;\n  }\n}\n\nmodule.exports = TranslationParser;\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(2932);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC55BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC5pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC1eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChSA;AACA;AACA;AACA;AACA;A;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACvjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AClCA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}